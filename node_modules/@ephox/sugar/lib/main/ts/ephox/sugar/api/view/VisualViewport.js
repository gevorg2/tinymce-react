import { window } from '@ephox/dom-globals';
import { Fun, Option } from '@ephox/katamari';
import { fromRawEvent } from '../../impl/FilteredEvent';
import Element from '../node/Element';
import * as Scroll from './Scroll';
var get = function (_win) {
    var win = _win === undefined ? window : _win;
    /* tslint:disable-next-line:no-string-literal */
    return Option.from(win['visualViewport']);
};
var bounds = function (x, y, width, height) {
    return {
        x: Fun.constant(x),
        y: Fun.constant(y),
        width: Fun.constant(width),
        height: Fun.constant(height),
        right: Fun.constant(x + width),
        bottom: Fun.constant(y + height)
    };
};
var getBounds = function (_win) {
    var win = _win === undefined ? window : _win;
    var doc = win.document;
    var scroll = Scroll.get(Element.fromDom(doc));
    return get(win).fold(function () {
        var html = win.document.documentElement;
        // Don't use window.innerWidth/innerHeight here, as we don't want to include scrollbars
        // since the right/bottom position is based on the edge of the scrollbar not the window
        var width = html.clientWidth;
        var height = html.clientHeight;
        return bounds(scroll.left(), scroll.top(), width, height);
    }, function (visualViewport) {
        // iOS doesn't update the pageTop/pageLeft when element.scrollIntoView() is called, so we need to fallback to the
        // scroll position which will always be less than the page top/left values when page top/left are accurate/correct.
        return bounds(Math.max(visualViewport.pageLeft, scroll.left()), Math.max(visualViewport.pageTop, scroll.top()), visualViewport.width, visualViewport.height);
    });
};
var bind = function (name, callback, _win) {
    return get(_win).map(function (visualViewport) {
        var handler = function (e) { return fromRawEvent(e); };
        visualViewport.addEventListener(name, handler);
        return {
            unbind: function () { return visualViewport.removeEventListener(name, handler); }
        };
    }).getOrThunk(function () {
        return {
            unbind: Fun.noop
        };
    });
};
export { bind, get, getBounds };
//# sourceMappingURL=VisualViewport.js.map