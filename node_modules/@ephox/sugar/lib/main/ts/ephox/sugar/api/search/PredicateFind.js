import { Arr, Fun, Option, Type } from '@ephox/katamari';
import ClosestOrAncestor from '../../impl/ClosestOrAncestor';
import * as Compare from '../dom/Compare';
import * as Body from '../node/Body';
import Element from '../node/Element';
var first = function (predicate) {
    return descendant(Body.body(), predicate);
};
var ancestor = function (scope, predicate, isRoot) {
    var element = scope.dom();
    var stop = Type.isFunction(isRoot) ? isRoot : Fun.constant(false);
    while (element.parentNode) {
        element = element.parentNode;
        var el = Element.fromDom(element);
        if (predicate(el)) {
            return Option.some(el);
        }
        else if (stop(el)) {
            break;
        }
    }
    return Option.none();
};
var closest = function (scope, predicate, isRoot) {
    // This is required to avoid ClosestOrAncestor passing the predicate to itself
    var is = function (s, test) {
        return test(s);
    };
    return ClosestOrAncestor(is, ancestor, scope, predicate, isRoot);
};
var sibling = function (scope, predicate) {
    var element = scope.dom();
    if (!element.parentNode) {
        return Option.none();
    }
    return child(Element.fromDom(element.parentNode), function (x) {
        return !Compare.eq(scope, x) && predicate(x);
    });
};
var child = function (scope, predicate) {
    var pred = function (node) { return predicate(Element.fromDom(node)); };
    var result = Arr.find(scope.dom().childNodes, pred);
    return result.map(Element.fromDom);
};
var descendant = function (scope, predicate) {
    var descend = function (node) {
        // tslint:disable-next-line:prefer-for-of
        for (var i = 0; i < node.childNodes.length; i++) {
            var child_1 = Element.fromDom(node.childNodes[i]);
            if (predicate(child_1)) {
                return Option.some(child_1);
            }
            var res = descend(node.childNodes[i]);
            if (res.isSome()) {
                return res;
            }
        }
        return Option.none();
    };
    return descend(scope.dom());
};
export { first, ancestor, closest, sibling, child, descendant, };
//# sourceMappingURL=PredicateFind.js.map