"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Lint = require("tslint");
var ts = require("typescript");
var Arr = require("../utils/Arr");
var Rule = /** @class */ (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));
    };
    Rule.metadata = {
        description: 'Disallows usage of Promise without importing a featurefill.',
        options: {},
        optionsDescription: '',
        requiresTypeInfo: false,
        ruleName: 'no-unimported-promise',
        type: 'functionality',
        typescriptOnly: false
    };
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
var isPromiseImport = function (node) {
    if (ts.isImportDeclaration(node) && node.importClause && node.importClause.namedBindings && ts.isNamedImports(node.importClause.namedBindings)) {
        return Arr.exists(node.importClause.namedBindings.elements, function (element) {
            return ts.isImportSpecifier(element) && ts.isIdentifier(element.name) && element.name.text === 'Promise';
        });
    }
    else if (ts.isImportDeclaration(node) && node.importClause && node.importClause.name && ts.isIdentifier(node.importClause.name)) {
        return node.importClause.name.text === 'Promise';
    }
    else {
        return false;
    }
};
var noPromiseImportErrorMessage = "Promise needs a featurefill import since IE 11 doesn't have native support.";
// tslint:disable-next-line:max-classes-per-file
var Walker = /** @class */ (function (_super) {
    tslib_1.__extends(Walker, _super);
    function Walker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Walker.prototype.visitCallExpression = function (node) {
        var noPromiseImport = Arr.notExists(this.getSourceFile().statements, isPromiseImport);
        if (ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.expression) && node.expression.expression.text === 'Promise' && noPromiseImport) {
            this.addFailureAtNode(node, noPromiseImportErrorMessage);
        }
        _super.prototype.visitCallExpression.call(this, node);
    };
    Walker.prototype.visitNewExpression = function (node) {
        var noPromiseImport = Arr.notExists(this.getSourceFile().statements, isPromiseImport);
        if (ts.isIdentifier(node.expression) && node.expression.text === 'Promise' && noPromiseImport) {
            this.addFailureAtNode(node, noPromiseImportErrorMessage);
        }
        _super.prototype.visitNewExpression.call(this, node);
    };
    return Walker;
}(Lint.RuleWalker));
//# sourceMappingURL=noUnimportedPromiseRule.js.map