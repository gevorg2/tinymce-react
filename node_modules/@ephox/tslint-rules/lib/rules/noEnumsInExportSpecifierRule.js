"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Lint = require("tslint");
var ts = require("typescript");
var Rule = /** @class */ (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));
    };
    Rule.metadata = {
        description: 'Disallows enums to be exported though export specifier at the end of the file.',
        options: {},
        optionsDescription: '',
        requiresTypeInfo: false,
        ruleName: 'no-enums-in-export-specifier',
        type: 'functionality',
        typescriptOnly: false
    };
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
// tslint:disable-next-line:max-classes-per-file
var Walker = /** @class */ (function (_super) {
    tslib_1.__extends(Walker, _super);
    function Walker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Walker.prototype.visitEnumDeclaration = function (enumNode) {
        var _this = this;
        var hasExport = enumNode.modifiers && enumNode.modifiers.findIndex(function (mod) { return mod.kind === ts.SyntaxKind.ExportKeyword; }) !== -1;
        if (!hasExport && enumNode.parent.kind === ts.SyntaxKind.SourceFile) {
            var name_1 = enumNode.name.text;
            var sourceFile = enumNode.parent;
            var exportDeclaration = sourceFile.statements.find(function (node) { return node.kind === ts.SyntaxKind.ExportDeclaration; });
            if (exportDeclaration && exportDeclaration.exportClause) {
                exportDeclaration.exportClause.elements.forEach(function (exportSpecifier) {
                    if (exportSpecifier.name.text === name_1) {
                        _this.addFailureAtNode(exportSpecifier, "Exports of enums needs to be where it's being declared.");
                    }
                });
            }
        }
        _super.prototype.visitEnumDeclaration.call(this, enumNode);
    };
    return Walker;
}(Lint.RuleWalker));
//# sourceMappingURL=noEnumsInExportSpecifierRule.js.map