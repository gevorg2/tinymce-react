import { Chain, Mouse, NamedChain, UiFinder } from '@ephox/agar';
import { Fun } from '@ephox/katamari';
import { Element, Visibility, Body } from '@ephox/sugar';
import { getThemeSelectors } from './ThemeSelectors';
var cToolstripRoot = Chain.mapper(function (editor) {
    return Element.fromDom(editor.getContainer());
});
var cEditorRoot = Chain.mapper(function (editor) {
    return Element.fromDom(editor.getBody());
});
var cDialogRoot = Chain.injectThunked(Body.body);
var cGetToolbarRoot = NamedChain.asChain([
    NamedChain.direct(NamedChain.inputName(), Chain.identity, 'editor'),
    NamedChain.direct('editor', cToolstripRoot, 'container'),
    NamedChain.merge(['editor', 'container'], 'data'),
    NamedChain.direct('data', Chain.binder(function (data) {
        return UiFinder.findIn(data.container, getThemeSelectors().toolBarSelector(data.editor));
    }), 'toolbar'),
    NamedChain.output('toolbar')
]);
var cGetMenuRoot = Chain.fromChains([
    cToolstripRoot,
    Chain.binder(function (container) {
        return UiFinder.findIn(container, getThemeSelectors().menuBarSelector);
    })
]);
var cClickOnWithin = function (label, selector, cContext) {
    return NamedChain.asChain([
        NamedChain.direct(NamedChain.inputName(), cContext, 'context'),
        NamedChain.direct('context', UiFinder.cFindIn(selector), 'ui'),
        NamedChain.direct('ui', Mouse.cClick, '_'),
        NamedChain.outputInput
    ]);
};
var cClickOnUi = function (label, selector) {
    return cClickOnWithin(label, selector, cDialogRoot);
};
var cClickOnToolbar = function (label, selector) {
    return cClickOnWithin(label, selector, cGetToolbarRoot);
};
var cClickOnMenu = function (label, selector) {
    return cClickOnWithin(label, selector, cGetMenuRoot);
};
var cWaitForState = function (hasState) {
    return function (label, selector) {
        return NamedChain.asChain([
            NamedChain.write('element', Chain.fromChains([
                cDialogRoot,
                UiFinder.cWaitForState(label, selector, hasState)
            ])),
            NamedChain.outputInput
        ]);
    };
};
var cWaitForVisible = function (label, selector) {
    return Chain.fromChains([
        cDialogRoot,
        UiFinder.cWaitForState(label, selector, Visibility.isVisible)
    ]);
};
var cWaitForPopup = function (label, selector) {
    return cWaitForState(Visibility.isVisible)(label, selector);
};
var cWaitForUi = function (label, selector) {
    return cWaitForState(Fun.constant(true))(label, selector);
};
var cTriggerContextMenu = function (label, target, menu) {
    return Chain.fromChains([
        cEditorRoot,
        UiFinder.cFindIn(target),
        Mouse.cContextMenu,
        // Ignores input
        cWaitForPopup(label, menu)
    ]);
};
var cClickPopupButton = function (btnType, selector) {
    var popupSelector = selector ? selector : '[role="dialog"]';
    return NamedChain.asChain([
        NamedChain.direct(NamedChain.inputName(), cWaitForVisible('waiting for: ' + popupSelector, popupSelector), 'popup'),
        NamedChain.direct('popup', Chain.binder(function (container) { return UiFinder.findIn(container, getThemeSelectors()[btnType]); }), 'button'),
        NamedChain.direct('button', Mouse.cClick, '_'),
        NamedChain.outputInput
    ]);
};
var cCloseDialog = function (selector) {
    return cClickPopupButton('dialogCloseSelector', selector);
};
var cSubmitDialog = function (selector) {
    return cClickPopupButton('dialogSubmitSelector', selector);
};
export var UiChains = {
    cClickOnToolbar: cClickOnToolbar,
    cClickOnMenu: cClickOnMenu,
    cClickOnUi: cClickOnUi,
    // Popups need to be visible.
    cWaitForPopup: cWaitForPopup,
    // UI does not need to be visible
    cWaitForUi: cWaitForUi,
    // General state predicate
    cWaitForState: cWaitForState,
    cCloseDialog: cCloseDialog,
    cSubmitDialog: cSubmitDialog,
    cTriggerContextMenu: cTriggerContextMenu
};
//# sourceMappingURL=UiChains.js.map