import { TestLogs } from "./TestLogs";
var Global = (function () {
    if (typeof window !== 'undefined') {
        return window;
    }
    else {
        return Function('return this;')();
    }
})();
var register = function (name, test) {
    if (typeof Global.__tests === 'undefined') {
        Global.__tests = [];
    }
    Global.__tests.push({ name: name, test: test });
};
var cleanStack = function (error, linesToRemove) {
    if (linesToRemove === void 0) { linesToRemove = 1; }
    if (error.stack === undefined) {
        return '';
    }
    var lines = error.stack.split('\n');
    var message = lines[0];
    var stack = lines.slice(1 + linesToRemove);
    return message + '\n' + stack.join('\n');
};
var normalizeError = function (err) {
    if (typeof err === 'string') {
        // Create an error object, but strip the stack of the 2 latest calls as it'll
        // just be this function and the previous function that called this (ie asyncTest)
        var error = new Error(err);
        error.stack = cleanStack(error, 2);
        return error;
    }
    else if (typeof err === 'function') {
        return normalizeError(err());
    }
    else {
        return err;
    }
};
var processLog = function (logs) {
    var outputToStr = function (numIndent, entries) {
        var everything = [];
        var indentString = '';
        for (var i = 0; i < numIndent; i++) {
            indentString += ' ';
        }
        var _loop_1 = function (i) {
            var entry = entries[i];
            var output = (function () {
                var traceLines = entry.trace === null || typeof entry.trace !== 'string' ? [] : ['', '', ''].concat(entry.trace.split('\n'));
                if (entry.entries.length === 0) {
                    if (entry.trace === null) {
                        return [indentString + '*  ' + entry.message];
                    }
                    else {
                        return [indentString + '*  ' + entry.message].concat(traceLines);
                    }
                }
                else {
                    // We have entries ... let's format them.
                    return [indentString + '*  ' + entry.message].concat(outputToStr(numIndent + 2, entry.entries)).concat(traceLines);
                }
            })();
            everything = everything.concat(output);
        };
        for (var i = 0; i < entries.length; i++) {
            _loop_1(i);
        }
        return everything;
    };
    return outputToStr(2, logs.history);
};
var prepFailure = function (err, logs) {
    if (logs === void 0) { logs = TestLogs.emptyLogs(); }
    var normalizedErr = normalizeError(err);
    var failureMessage = processLog(logs);
    return {
        error: normalizedErr,
        logs: failureMessage,
    };
};
export var asynctest = function (name, test) {
    register(name, function (success, failure) {
        test(success, function (err, logs) {
            if (logs === void 0) { logs = TestLogs.emptyLogs(); }
            var r = prepFailure(err, logs);
            failure(r);
        });
    });
};
export var test = function (name, test) {
    register(name, function (success, failure) {
        try {
            test();
            success();
        }
        catch (e) {
            var r = prepFailure(e);
            failure(r);
        }
    });
};
//# sourceMappingURL=UnitTest.js.map