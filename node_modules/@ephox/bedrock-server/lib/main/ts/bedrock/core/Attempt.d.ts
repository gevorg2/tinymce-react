export interface Attempt<E, A> {
    foldAttempt: <B>(onFailed: (e: E) => B, onPassed: (a: A) => B) => B;
}
export declare const Attempt: {
    failed: <E, A>(err: E) => Attempt<E, A>;
    passed: <E_1, A_1>(value: A_1) => Attempt<E_1, A_1>;
    cata: <E_2, A_2, B>(attempt: Attempt<E_2, A_2>, onFailed: (e: E_2) => B, onPassed: (a: A_2) => B) => B;
    bind: <E_3, A_3, B_1>(firstAttempt: Attempt<E_3, A_3>, f: (a: A_3) => Attempt<E_3, B_1>) => Attempt<E_3, B_1>;
    map: <E_4, A_4, B_2>(firstAttempt: Attempt<E_4, A_4>, f: (a: A_4) => B_2) => Attempt<E_4, B_2>;
    list: <E_5, A_5>(firstAttempt: Attempt<E_5, A_5>, fs: ((a: A_5) => Attempt<E_5, A_5>)[]) => Attempt<E_5, A_5>;
    carry: <E_6, A_6, B_3, C>(firstAttempt: Attempt<E_6[], A_6>, secondAttempt: Attempt<E_6[], B_3>, f: (a: A_6, b: B_3) => Attempt<E_6[], C>) => Attempt<E_6[], C>;
    concat: <E_7, A_7>(attempts: Attempt<E_7[], A_7>[]) => Attempt<E_7[], A_7[]>;
    toString: <E_8, A_8>(attempt: Attempt<E_8, A_8>) => string;
    hasPassed: <E_9, A_9>(attempt: Attempt<E_9, A_9>) => boolean;
};
