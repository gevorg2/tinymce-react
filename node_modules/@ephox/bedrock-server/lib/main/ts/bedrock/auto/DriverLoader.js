"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crossSpawn = require("cross-spawn");
const http = require("http");
const browserModules = {
    'chrome': 'chromedriver',
    'firefox': 'geckodriver',
    'internet explorer': 'iedriver',
    'MicrosoftEdge': 'edgedriver'
};
const browserExecutables = {
    'safari': 'safaridriver',
    'chrome': 'chromedriver',
    'firefox': 'geckodriver',
    'internet explorer': 'IEDriverServer',
    'MicrosoftEdge': 'MicrosoftWebDriver'
};
const execLoader = (exec, driverArgs = []) => {
    const api = {};
    api.start = (args = []) => {
        const finalArgs = driverArgs.concat(args);
        api.defaultInstance = crossSpawn(exec, finalArgs);
        return api.defaultInstance;
    };
    api.stop = () => {
        if (api.defaultInstance) {
            api.defaultInstance.kill();
            api.defaultInstance = null;
        }
    };
    return api;
};
const loadPhantomJs = () => {
    const api = execLoader('phantomjs');
    // Patch the start function to remap the arguments
    const origStart = api.start;
    api.start = (args = []) => {
        const patchedArgs = args.map((arg) => {
            return arg.indexOf('--port') !== -1 ? arg.replace('--port', '--webdriver') : arg;
        });
        return origStart(patchedArgs);
    };
    return api;
};
exports.loadDriver = (browserName) => {
    const driverDep = browserModules[browserName];
    if (driverDep === undefined) {
        console.log('Not loading a local driver for browser ' + browserName);
    }
    else {
        try {
            return require(driverDep);
        }
        catch (e) {
            console.log(`No local ${driverDep} for ${browserName}. Searching system path...`);
        }
    }
    const execName = browserExecutables[browserName] || driverDep;
    if (browserName === 'phantomjs') {
        return loadPhantomJs();
    }
    else if (execName !== undefined) {
        return execLoader(execName);
    }
    else {
        throw new Error('Unable to find a suitable driver for ' + browserName);
    }
};
exports.waitForAlive = (proc, port, timeout = 30000) => {
    const url = 'http://localhost:' + port + '/status';
    const start = Date.now();
    return new Promise((resolve, reject) => {
        let timeoutId = null;
        const onStartError = (error) => {
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
            reject('Driver failed to start (' + error + ')');
        };
        const onServerError = (err) => {
            if (Date.now() - start > timeout) {
                reject('Timed out waiting for the webdriver server. Error: ' + err);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                timeoutId = setTimeout(checkServerStatus, 50);
            }
        };
        const checkServerStatus = () => {
            http.get(url, (res) => {
                if (res.statusCode === 200) {
                    let rawData = '';
                    res.on('data', (chunk) => rawData += chunk);
                    res.on('end', () => {
                        try {
                            const data = JSON.parse(rawData);
                            if (data.value.ready || data.status === 0) {
                                proc.removeListener('exit', onStartError);
                                proc.removeListener('error', onStartError);
                                resolve();
                            }
                            else {
                                onServerError('Not ready to accept connections');
                            }
                        }
                        catch (e) {
                            onServerError(e.message);
                        }
                    });
                }
                else {
                    onServerError('Received non 200 status (' + res.statusCode + ')');
                }
            }).on('error', onServerError);
        };
        // Bind process listeners
        proc.on('exit', onStartError);
        proc.on('error', onStartError);
        // Start listening for the server to be ready
        checkServerStatus();
    });
};
exports.startAndWaitForAlive = (driverApi, port, timeout = 30000) => {
    // Start the driver
    const driverProc = driverApi.start(['--port=' + port]);
    // Wait for it to be alive
    return exports.waitForAlive(driverProc, port, timeout);
};
//# sourceMappingURL=DriverLoader.js.map