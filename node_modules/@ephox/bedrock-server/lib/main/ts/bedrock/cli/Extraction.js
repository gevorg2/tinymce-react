"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const readdirSyncRec = require("recursive-readdir-sync");
const Attempt_1 = require("../core/Attempt");
const Qstring = require("../util/Qstring");
exports.file = (name, rawValue) => {
    // Ignore any query strings when checking if a file exists
    const parsed = Qstring.parse(rawValue);
    const value = parsed.base;
    try {
        fs.accessSync(value);
        if (!fs.statSync(value).isFile()) {
            return Attempt_1.Attempt.failed(['Property: ' + name + ' => Value: ' + value + ' was not a file']);
        }
        return Attempt_1.Attempt.passed(parsed.original);
    }
    catch (err) {
        return Attempt_1.Attempt.failed(['Property [' + name + '] has value: [' + value + ']. This file does not exist']);
    }
};
exports.inSet = (candidates) => {
    return (name, value) => {
        if (candidates.indexOf(value) === -1) {
            return Attempt_1.Attempt.failed([
                'Invalid value for property: ' + name + '. Actual value: ' + value + '. Required value: one of ' + JSON.stringify(candidates)
            ]);
        }
        else {
            return Attempt_1.Attempt.passed(value);
        }
    };
};
exports.any = (name, value) => {
    return Attempt_1.Attempt.passed(value);
};
exports.directory = (name, value) => {
    try {
        if (!fs.lstatSync(value).isDirectory())
            return Attempt_1.Attempt.failed(['[' + value + '] is not a directory']);
        return Attempt_1.Attempt.passed(value);
    }
    catch (err) {
        return Attempt_1.Attempt.failed(['[' + value + '] is not a directory']);
    }
};
exports.files = (patterns) => {
    return (name, value) => {
        const dir = exports.directory(name, value);
        return Attempt_1.Attempt.bind(dir, (d) => {
            try {
                const scanned = readdirSyncRec(d).filter((f) => {
                    const matches = patterns.filter((p) => {
                        return f.indexOf(p) > -1;
                    });
                    return matches.length > 0 && fs.lstatSync(f).isFile();
                });
                return Attempt_1.Attempt.passed(scanned);
            }
            catch (err) {
                return Attempt_1.Attempt.failed([
                    'Error scanning directory [' + d + '] for files matching pattern: [' + patterns.join(', ') + ']'
                ]);
            }
        });
    };
};
//# sourceMappingURL=Extraction.js.map