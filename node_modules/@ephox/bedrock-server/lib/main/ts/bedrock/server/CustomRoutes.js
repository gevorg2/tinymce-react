"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const Matchers = require("./Matchers");
const Obj = require("../util/Obj");
const Type = require("../util/Type");
const Routes = require("./Routes");
const FileUtils = require("../util/FileUtils");
const readRequestBody = (request, done) => {
    let body = '';
    request.on('data', (data) => {
        body += data;
    });
    request.on('end', () => {
        done(body);
    });
};
const serializeJson = (json) => {
    return JSON.stringify(json, null, 2);
};
const matchesFromRequest = (matchRequest) => {
    const matches = [];
    if (Type.isString(matchRequest.method)) {
        matches.push(Matchers.methodMatch(matchRequest.method));
    }
    if (Type.isString(matchRequest.url)) {
        matches.push(Matchers.urlMatch(matchRequest.url));
    }
    if (Type.isString(matchRequest.path)) {
        matches.push(Matchers.pathMatch(matchRequest.path));
    }
    if (Type.isObject(matchRequest.headers)) {
        matches.push(Matchers.headersMatch(matchRequest.headers));
    }
    if (Type.isObject(matchRequest.query)) {
        matches.push(Matchers.queryMatch(matchRequest.query));
    }
    if (!Type.isNull(matchRequest.json) && !Type.isUndefined(matchRequest.json)) {
        matches.push(Matchers.jsonBodyMatch(matchRequest.json));
    }
    return matches;
};
const parseJsonFromFile = (filePath, configPath) => {
    const resolvedFilePath = path.join(path.dirname(configPath), filePath);
    return FileUtils.readFileAsJson(resolvedFilePath);
};
const assignContentType = (headers, contentType) => {
    return Object.assign({}, { 'content-type': contentType }, headers);
};
const concludeJson = (response, status, headers, json) => {
    response.writeHead(status, assignContentType(headers, 'application/json'));
    response.end(serializeJson(json));
};
const goFromResponse = (matchResponse, configPath) => {
    return (request, response /* , done */) => {
        const headers = matchResponse.headers ? Obj.toLowerCaseKeys(matchResponse.headers) : {};
        const status = matchResponse.status ? matchResponse.status : 200;
        if (!Type.isNull(matchResponse.json) && !Type.isUndefined(matchResponse.json)) {
            concludeJson(response, status, headers, matchResponse.json);
        }
        else if (Type.isString(matchResponse.json_file)) {
            const json = parseJsonFromFile(matchResponse.json_file, configPath);
            concludeJson(response, status, headers, json);
        }
    };
};
const jsonToRouters = (data, configPath) => {
    return data.map((staticRouter) => {
        return {
            matches: matchesFromRequest(staticRouter.request),
            go: goFromResponse(staticRouter.response, configPath)
        };
    });
};
const fallbackGo = (filePath) => {
    return (request, response, done) => {
        response.writeHead(404, { 'content-type': 'text/plain' });
        response.end([
            'Could not find a matching custom route for: ',
            'Method: ' + request.method,
            'Url: ' + request.url,
            'Body: ' + request.body,
            'Config: ' + (filePath ? filePath : 'No config file provided')
        ].join('\n'));
        done();
    };
};
const go = (filePath) => {
    const fallback = { matches: [], go: fallbackGo(filePath) };
    return (request, response, done) => {
        const routers = filePath ? jsonToRouters(FileUtils.readFileAsJson(filePath), filePath) : [];
        readRequestBody(request, (body) => {
            request.body = body;
            Routes.route(routers, fallback, request, response, done);
        });
    };
};
const routers = (filePath) => {
    return [
        {
            matches: [Matchers.prefixMatch('/custom')],
            go: go(filePath)
        }
    ];
};
exports.create = (filePath) => {
    return {
        routers: routers(filePath)
    };
};
//# sourceMappingURL=CustomRoutes.js.map