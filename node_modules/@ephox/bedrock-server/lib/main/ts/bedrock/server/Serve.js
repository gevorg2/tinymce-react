"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const finalhandler = require("finalhandler");
const http = require("http");
const portfinder = require("portfinder");
const Routes = require("./Routes");
const Apis = require("./Apis");
const CustomRoutes = require("./CustomRoutes");
/*
 * Settings:
 *
 * projectdir: project directory (what you are testing)
 * basedir: the directory of bedrock
 * testfiles: the test files to test (an array)
 * driver: (optional). Required for supporting keys,
 * master (can be null) The driver master (locking and unlocking)
 * runner: runner (e.g. runnerroutes, pageroutes etc). Has fallback and routers.
 */
exports.startCustom = (settings, createServer) => {
    const pref = (f) => {
        const v = settings[f];
        if (v === undefined) {
            throw new Error('Object: does not have field: ' + f);
        }
        return v;
    };
    const cr = CustomRoutes.create(settings.customRoutes);
    const basedir = pref('basedir');
    const projectdir = pref('projectdir');
    const testfiles = pref('testfiles');
    const maybeDriver = pref('driver');
    const master = pref('master');
    const stickyFirstSession = settings.stickyFirstSession;
    const singleTimeout = pref('singleTimeout');
    const overallTimeout = pref('overallTimeout');
    const resetMousePosition = !pref('skipResetMousePosition');
    const runner = pref('runner');
    const api = Apis.create(master, maybeDriver, projectdir, basedir, stickyFirstSession, singleTimeout, overallTimeout, testfiles, settings.loglevel, resetMousePosition);
    const routers = runner.routers.concat(api.routers, cr.routers);
    const fallback = runner.fallback;
    return portfinder.getPortPromise({
        port: 8000,
        stopPort: 20000
    }).catch((err) => {
        return Promise.reject('Error looking for open port between 8000 and 20000: ' + err);
    }).then((port) => {
        const server = createServer((request, response) => {
            const done = finalhandler(request, response);
            Routes.route(routers, fallback, request, response, done);
        }).listen(port);
        return {
            port: port,
            server: server,
            markLoaded: api.markLoaded,
            enableHud: api.enableHud,
            awaitDone: api.awaitDone,
            shutdown: () => {
                return new Promise((resolve) => {
                    server.close();
                    // TODO: Find out why this doesn't shutdown quickly as we may not be closing connections properly
                    // For now though give the server 1 sec to shutdown gracefully
                    setTimeout(resolve, 1000);
                });
            }
        };
    });
};
exports.start = (settings) => {
    return exports.startCustom(settings, http.createServer);
};
//# sourceMappingURL=Serve.js.map