"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mocha_1 = require("mocha");
const Attempt_1 = require("../../main/ts/bedrock/core/Attempt");
const fc = require("fast-check");
const deepEqual = require("fast-deep-equal");
const AttemptUtils_1 = require("./AttemptUtils");
mocha_1.describe('attempt.carry', () => {
    mocha_1.it('attempt.carry [ f([err1]), f([err2]) ]', () => {
        AttemptUtils_1.assertErrors(['err1', 'err2'], Attempt_1.Attempt.carry(Attempt_1.Attempt.failed(['err1']), Attempt_1.Attempt.failed(['err2']), Attempt_1.Attempt.passed));
    });
    mocha_1.it('attempt.carry [ f([err1]), p(good) ]', () => {
        AttemptUtils_1.assertErrors(['err1'], Attempt_1.Attempt.carry(Attempt_1.Attempt.failed(['err1']), Attempt_1.Attempt.passed('good'), Attempt_1.Attempt.passed));
    });
    mocha_1.it('attempt.carry [ p(good), f([bad]) ]', () => {
        AttemptUtils_1.assertErrors(['bad'], Attempt_1.Attempt.carry(Attempt_1.Attempt.passed('good'), Attempt_1.Attempt.failed(['bad']), Attempt_1.Attempt.passed));
    });
});
mocha_1.describe('attempt.concat', () => {
    mocha_1.it('attempt.concat [ ]', () => {
        AttemptUtils_1.assertResult([], Attempt_1.Attempt.concat([]));
    });
    mocha_1.it('attempt.concat [ p(1) ]', () => {
        AttemptUtils_1.assertResult([1], Attempt_1.Attempt.concat([
            Attempt_1.Attempt.passed(1)
        ]));
    });
    mocha_1.it('attempt.concat [ p(1), p(2), p(3) ]', () => {
        AttemptUtils_1.assertResult([1, 2, 3], Attempt_1.Attempt.concat([
            Attempt_1.Attempt.passed(1),
            Attempt_1.Attempt.passed(2),
            Attempt_1.Attempt.passed(3)
        ]));
    });
    mocha_1.it('attempt.concat [ p(1), f([message]), p(3) ]', () => {
        AttemptUtils_1.assertErrors(['message1', 'message2'], Attempt_1.Attempt.concat([
            Attempt_1.Attempt.passed(1),
            Attempt_1.Attempt.failed(['message1', 'message2']),
            Attempt_1.Attempt.passed(3)
        ]));
    });
    mocha_1.it('attempt.concat [ p(1), f([message1,2]), f([message3,4]) ]', () => {
        AttemptUtils_1.assertErrors(['message1', 'message2', 'message3', 'message4'], Attempt_1.Attempt.concat([
            Attempt_1.Attempt.passed(1),
            Attempt_1.Attempt.failed(['message1', 'message2']),
            Attempt_1.Attempt.failed(['message3', 'message4'])
        ]));
    });
});
mocha_1.describe('attempt.list', () => {
    mocha_1.it('attempt.list p(1) -> [ =>f[a], =>p(1) ]', () => {
        AttemptUtils_1.assertErrors(['f.1'], Attempt_1.Attempt.list(Attempt_1.Attempt.passed('1'), [
            i => Attempt_1.Attempt.failed(['f.' + i]),
            () => Attempt_1.Attempt.passed('done')
        ]));
    });
    mocha_1.it('attempt.list p(1) -> [ =>p(1.*), =>p(2.*), =>p(3.*) ]', () => {
        AttemptUtils_1.assertResult('3.2.1.0', Attempt_1.Attempt.list(Attempt_1.Attempt.passed('0'), [
            i => Attempt_1.Attempt.passed('1.' + i),
            i => Attempt_1.Attempt.passed('2.' + i),
            i => Attempt_1.Attempt.passed('3.' + i)
        ]));
    });
});
mocha_1.describe("Attempt.hasPassed", () => {
    mocha_1.it('is true when passed', () => {
        fc.assert(fc.property(AttemptUtils_1.arbAttemptPassed(fc.nat()), Attempt_1.Attempt.hasPassed));
    });
    mocha_1.it('is false when failed', () => {
        fc.assert(fc.property(AttemptUtils_1.arbAttemptFailed(fc.nat()), (x) => !Attempt_1.Attempt.hasPassed(x)));
    });
});
mocha_1.describe("Attempt.concat", () => {
    mocha_1.it("passes if all true", () => {
        fc.assert(fc.property(fc.array(AttemptUtils_1.arbAttemptPassed(fc.nat())), (attempts) => Attempt_1.Attempt.hasPassed(Attempt_1.Attempt.concat(attempts))));
    });
    mocha_1.it('fails if any have failed', () => {
        fc.assert(fc.property(fc.array(AttemptUtils_1.arbAttempt(fc.array(fc.string()), fc.nat())), (attempts) => {
            const result = Attempt_1.Attempt.concat(attempts);
            const allPassed = attempts.filter(Attempt_1.Attempt.hasPassed).length === attempts.length;
            return Attempt_1.Attempt.hasPassed(result) === allPassed;
        }));
    });
    mocha_1.it('concatenates error messages', () => {
        fc.assert(fc.property(fc.array(AttemptUtils_1.arbAttempt(fc.array(fc.string()), fc.nat())), (attempts) => {
            const result = Attempt_1.Attempt.concat(attempts);
            const failed = attempts.filter((at) => !Attempt_1.Attempt.hasPassed(at));
            const failedErrors = failed.reduce((rest, f) => {
                const current = Attempt_1.Attempt.cata(f, (x) => x, () => []);
                return rest.concat(current);
            }, []);
            return Attempt_1.Attempt.cata(result, (errs) => deepEqual(errs, failedErrors), (v) => deepEqual([], failed));
        }));
    });
});
//# sourceMappingURL=AttemptTest.js.map