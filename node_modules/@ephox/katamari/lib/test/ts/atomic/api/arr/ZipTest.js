import * as Arr from 'ephox/katamari/api/Arr';
import * as Obj from 'ephox/katamari/api/Obj';
import * as Unique from 'ephox/katamari/api/Unique';
import * as Zip from 'ephox/katamari/api/Zip';
import { Option } from 'ephox/katamari/api/Option';
import { UnitTest, Assert } from '@ephox/bedrock-client';
import fc from 'fast-check';
UnitTest.test('Zip: unit tests', function () {
    var check1 = function (expectedZipToObject, expectedZipToTuples, keys, values) {
        var sort = function (a, ord) {
            var c = a.slice();
            c.sort(ord);
            return c;
        };
        var eq = 0;
        var lt = -1;
        var gt = 1;
        var sortTuples = function (a) { return sort(a, function (a, b) { return (a.k === b.k ? a.v === b.v ? eq
            : a.v > b.v ? gt
                : lt
            : a.k > b.k ? gt
                : lt); }); };
        expectedZipToObject.fold(function () {
            Assert.throws('boom', function () { return Zip.zipToObject(keys, values); });
        }, function (expected) {
            Assert.eq('eq', expected, Zip.zipToObject(keys, values));
        });
        expectedZipToTuples.fold(function () {
            Assert.throws('boom', function () { return Zip.zipToTuples(keys, values); });
        }, function (expected) {
            Assert.eq('eq', sortTuples(expected), sortTuples(Zip.zipToTuples(keys, values)));
        });
    };
    check1(Option.some({ q: 'a', r: 'x' }), Option.some([{ k: 'q', v: 'a' }, { k: 'r', v: 'x' }]), ['q', 'r'], ['a', 'x']);
    check1(Option.some({}), Option.some([]), [], []);
    check1(Option.none(), Option.none(), [], ['x']);
    check1(Option.none(), Option.none(), [], ['x', 'y']);
    check1(Option.none(), Option.none(), ['q'], []);
    check1(Option.none(), Option.none(), ['q', 'r'], []);
    check1(Option.none(), Option.none(), ['q', 'r'], ['a']);
});
UnitTest.test('zipToObject has matching keys and values', function () {
    fc.assert(fc.property(fc.array(fc.asciiString(1, 30)), function (rawValues) {
        var values = Unique.stringArray(rawValues);
        var keys = Arr.map(values, function (v, i) { return i; });
        var output = Zip.zipToObject(keys, values);
        var oKeys = Obj.keys(output);
        Assert.eq('Output keys did not match', oKeys.length, values.length);
        Assert.eq('Output keys', true, Arr.forall(oKeys, function (oKey) {
            var index = parseInt(oKey, 10);
            var expected = values[index];
            return output[oKey] === expected;
        }));
    }));
});
UnitTest.test('zipToTuples matches corresponding tuples', function () {
    fc.assert(fc.property(fc.array(fc.integer()), fc.array(fc.integer()), function (keys, values) {
        if (keys.length !== values.length) {
            Assert.throws('Should throw with different lengths', function () { return Zip.zipToTuples(keys, values); });
        }
        else {
            var output = Zip.zipToTuples(keys, values);
            Assert.eq('Output keys did not match', keys.length, output.length);
            Assert.eq('', true, Arr.forall(output, function (x, i) { return x.k === keys[i] && x.v === values[i]; }));
        }
    }));
});
//# sourceMappingURL=ZipTest.js.map