/* tslint:disable:no-unimported-promise */
import * as Arr from 'ephox/katamari/api/Arr';
import * as Fun from 'ephox/katamari/api/Fun';
import { LazyValue } from 'ephox/katamari/api/LazyValue';
import * as LazyValues from 'ephox/katamari/api/LazyValues';
import { setTimeout } from '@ephox/dom-globals';
import { eqAsync, promiseTest } from 'ephox/katamari/test/AsyncProps';
import fc from 'fast-check';
var lazyCounter = function () {
    var counter = 0;
    return LazyValue.nu(function (callback) {
        counter++;
        callback(counter);
    });
};
promiseTest('LazyValue: get', function () { return new Promise(function (resolve, reject) {
    var lazy = lazyCounter();
    lazy.get(function (val) {
        eqAsync('LazyValue.get. The counter should be 1 after 1 call', 1, val, reject);
        lazy.get(function (val2) {
            eqAsync('LazyValue.get. The counter should still be 1 because it is cached. Was: ' + val2, 1, val2, reject);
            resolve();
        });
    });
}); });
promiseTest('LazyValue: map', function () { return new Promise(function (resolve, reject) {
    var f = function (x) { return x + 'hello'; };
    var lazy = LazyValue.nu(function (callback) {
        setTimeout(function () {
            callback('extra');
        }, 10);
    });
    lazy.map(f).get(function (fx) {
        eqAsync('LazyValue.map. Expected: extrahello, was: ' + fx, 'extrahello', fx, reject);
        resolve();
    });
}); });
promiseTest('LazyValue: isReady', function () { return new Promise(function (resolve, reject) {
    var lazy = LazyValue.nu(function (callback) {
        setTimeout(function () {
            callback('extra');
        }, 50);
    });
    eqAsync('LazyValue.isReady. Lazy value should not be ready yet.', false, lazy.isReady(), reject);
    lazy.get(function (v) {
        eqAsync('LazyValue.isReady. Lazy value should now be ready', true, lazy.isReady(), reject);
        resolve();
    });
}); });
promiseTest('LazyValue: pure', function () {
    return fc.assert(fc.asyncProperty(fc.integer(), function (i) { return new Promise(function (resolve, reject) {
        LazyValue.pure(i).get(function (v) {
            eqAsync('LazyValue.pure', i, v, reject);
            resolve();
        });
    }); }));
});
promiseTest('LazyValue: pure, map', function () {
    return fc.assert(fc.asyncProperty(fc.integer(), fc.func(fc.string()), function (i, f) { return new Promise(function (resolve, reject) {
        LazyValue.pure(i).map(f).get(function (v) {
            eqAsync('LazyValue.map', f(i), v, reject);
            resolve();
        });
    }); }));
});
promiseTest('LazyValue: delayed, map', function () {
    return fc.assert(fc.asyncProperty(fc.integer(), fc.func(fc.string()), function (i, f) { return new Promise(function (resolve, reject) {
        LazyValue.nu(function (c) {
            setTimeout(function () {
                c(i);
            }, 2);
        }).map(f).get(function (v) {
            eqAsync('LazyValue.map', f(i), v, reject);
            resolve();
        });
    }); }));
});
promiseTest('LazyValue: parallel', function () { return new Promise(function (resolve, reject) {
    var f = LazyValue.nu(function (callback) {
        setTimeout(Fun.curry(callback, 'apple'), 10);
    });
    var g = LazyValue.nu(function (callback) {
        setTimeout(Fun.curry(callback, 'banana'), 5);
    });
    var h = LazyValue.nu(function (callback) {
        callback('carrot');
    });
    LazyValues.par([f, g, h]).get(function (r) {
        eqAsync('r[0]', r[0], 'apple', reject);
        eqAsync('r[1]', r[1], 'banana', reject);
        eqAsync('r[2]', r[2], 'carrot', reject);
        resolve();
    });
}); });
promiseTest('LazyValue: parallel spec', function () { return fc.assert(fc.asyncProperty(fc.array(fc.integer(), 0, 20), function (vals) { return new Promise(function (resolve, reject) {
    var lazyVals = Arr.map(vals, LazyValue.pure);
    LazyValues.par(lazyVals).get(function (actual) {
        eqAsync('pars', vals, actual, reject);
        resolve();
    });
}); })); });
//# sourceMappingURL=LazyValueTest.js.map