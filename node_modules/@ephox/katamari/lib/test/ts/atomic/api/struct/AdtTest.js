import { Adt } from 'ephox/katamari/api/Adt';
import * as Arr from 'ephox/katamari/api/Arr';
import * as Fun from 'ephox/katamari/api/Fun';
import fc from 'fast-check';
import { UnitTest, Assert } from '@ephox/bedrock-client';
import { console } from '@ephox/dom-globals';
UnitTest.test('ADT Test', function () {
    var checkInvalid = function (message, f) {
        var error = false;
        try {
            f();
        }
        catch (e) {
            if (e === 'ADTWHOOPS') {
                // tslint:disable-next-line:no-console
                console.log('die function incorrectly called');
            }
            else {
                error = true;
            }
        }
        if (!error) {
            throw new Error('Unexpected pass: ' + message);
        }
    };
    var checkInvalidGenerate = function (cases, message) {
        checkInvalid('generate() did not throw an error. Input: "' + message + '\'', function () {
            Adt.generate(cases);
        });
    };
    checkInvalidGenerate({}, 'object instead of array');
    checkInvalidGenerate([], 'empty cases array');
    checkInvalidGenerate(['f'], 'array contains strings');
    checkInvalidGenerate([{}], 'empty case');
    checkInvalidGenerate([{ t: {} }], 'object case arguments');
    checkInvalidGenerate([{ cata: [] }], 'case named cata');
    checkInvalidGenerate([{ a: [] }, { a: [] }], 'duplicate names');
    checkInvalidGenerate([
        {
            one: [],
            two: []
        }
    ], 'two cases in one');
    // A real Adt from the soldier project
    var soldierBlock = Adt.generate([
        { none: [] },
        { root: ['target', 'block'] },
        { created: ['target', 'block'] },
        { actual: ['target', 'block'] }
    ]);
    var none = function () {
        Assert.eq('eq', 0, arguments.length);
    };
    var targetStr = 'target';
    var blockStr = 'block';
    var tag = function (target, block) {
        Assert.eq('eq', 2, arguments.length);
        Assert.eq('eq', targetStr, target);
        Assert.eq('eq', blockStr, block);
    };
    var die = function () {
        // this is used when an error is expected, so we need to use fancy tricks
        // to actually fail
        throw new Error('ADTWHOOPS');
    };
    // double functions because that makes actual use better
    var adtNone = soldierBlock.none();
    var adtRoot = soldierBlock.root(targetStr, blockStr);
    var adtCreated = soldierBlock.created(targetStr, blockStr);
    var adtActual = soldierBlock.actual(targetStr, blockStr);
    checkInvalid('tag passed to none', function () {
        adtNone.fold(tag, die, die, die);
    });
    checkInvalid('none passed to root', function () {
        adtRoot.fold(die, none, die, die);
    });
    checkInvalid('none passed to created', function () {
        adtCreated.fold(die, die, none, die);
    });
    checkInvalid('none passed to actual', function () {
        adtActual.fold(die, die, die, none);
    });
    // valid checks, so we can redefine die to be sensible now
    die = Fun.die('Well that was unexpected');
    adtNone.fold(none, die, die, die);
    adtRoot.fold(die, tag, die, die);
    adtCreated.fold(die, die, tag, die);
    adtActual.fold(die, die, die, tag);
    var cheese = Fun.constant('cheese');
    Assert.eq('eq', 'cheese', adtNone.fold(cheese, die, die, die));
    Assert.eq('eq', 'cheese', adtRoot.fold(die, cheese, die, die));
    Assert.eq('eq', 'cheese', adtCreated.fold(die, die, cheese, die));
    Assert.eq('eq', 'cheese', adtActual.fold(die, die, die, cheese));
});
var newAdt = Adt.generate([
    { nothing: [] },
    { unknown: ['guesses'] },
    { exact: ['value', 'precision'] }
]);
var arbNothing = fc.constant(newAdt.nothing());
var arbUnknown = fc.array(fc.string()).map(function (guesses) { return newAdt.unknown(guesses); });
var arbExact = fc.tuple(fc.integer(), fc.integer()).map(function (arr) { return newAdt.exact(arr[0], arr[1]); });
var arbAdt = fc.oneof(arbNothing, arbUnknown, arbExact);
var allKeys = ['nothing', 'unknown', 'exact'];
var arbKeys = fc.constantFrom.apply(fc, allKeys);
UnitTest.test('Error is thrown if not all arguments are supplied', function () {
    fc.assert(fc.property(arbAdt, fc.array(arbKeys, 1, 40), function (subject, exclusions) {
        var original = Arr.filter(allKeys, function (k) { return !Arr.contains(exclusions, k); });
        try {
            var branches = Arr.mapToObject(original, function () { return Fun.identity; });
            subject.match(branches);
            return false;
        }
        catch (err) {
            return err.message.indexOf('nothing') > -1;
        }
    }));
});
var record = function () {
    return Array.prototype.slice.call(arguments, 0);
};
UnitTest.test('adt.nothing.match should pass [ ]', function () {
    fc.assert(fc.property(arbNothing, function (subject) {
        var contents = subject.match({
            nothing: record,
            unknown: Fun.die('should not be unknown'),
            exact: Fun.die('should not be exact')
        });
        Assert.eq('eq', [], contents);
    }));
});
UnitTest.test('adt.nothing.match should be same as fold', function () {
    fc.assert(fc.property(arbNothing, function (subject) {
        var matched = subject.match({
            nothing: record,
            unknown: Fun.die('should not be unknown'),
            exact: Fun.die('should not be exact')
        });
        var folded = subject.fold(record, Fun.die('should not be unknown'), Fun.die('should not be exact'));
        Assert.eq('eq', matched, folded);
    }));
});
UnitTest.test('adt.unknown.match should pass 1 parameter: [ guesses ]', function () {
    fc.assert(fc.property(arbUnknown, function (subject) {
        var contents = subject.match({
            nothing: Fun.die('should not be nothing'),
            unknown: record,
            exact: Fun.die('should not be exact')
        });
        Assert.eq('eq', 1, contents.length);
    }));
});
UnitTest.test('adt.unknown.match should be same as fold', function () {
    fc.assert(fc.property(arbUnknown, function (subject) {
        var matched = subject.match({
            nothing: Fun.die('should not be nothing'),
            unknown: record,
            exact: Fun.die('should not be exact')
        });
        var folded = subject.fold(Fun.die('should not be nothing'), record, Fun.die('should not be exact'));
        Assert.eq('eq', matched, folded);
    }));
});
UnitTest.test('adt.exact.match should pass 2 parameters [ value, precision ]', function () {
    fc.assert(fc.property(arbExact, function (subject) {
        var contents = subject.match({
            nothing: Fun.die('should not be nothing'),
            unknown: Fun.die('should not be unknown'),
            exact: record
        });
        Assert.eq('eq', 2, contents.length);
    }));
});
UnitTest.test('adt.exact.match should be same as fold', function () {
    fc.assert(fc.property(arbExact, function (subject) {
        var matched = subject.match({
            nothing: Fun.die('should not be nothing'),
            unknown: Fun.die('should not be unknown'),
            exact: record
        });
        var folded = subject.fold(Fun.die('should not be nothing'), Fun.die('should not be unknown'), record);
        Assert.eq('eq', matched, folded);
    }));
});
UnitTest.test('adt.match must have the right arguments, not just the right number', function () {
    fc.assert(fc.property(arbAdt, function (subject) {
        try {
            subject.match({
                not: Fun.identity,
                the: Fun.identity,
                right: Fun.identity
            });
            return false;
        }
        catch (err) {
            return err.message.indexOf('nothing') > -1;
        }
    }));
});
//# sourceMappingURL=AdtTest.js.map