/* tslint:disable:no-unimported-promise */
import * as Arr from 'ephox/katamari/api/Arr';
import * as Fun from 'ephox/katamari/api/Fun';
import { Future } from 'ephox/katamari/api/Future';
import * as Futures from 'ephox/katamari/api/Futures';
import { promiseTest, eqAsync } from 'ephox/katamari/test/AsyncProps';
import { setTimeout } from '@ephox/dom-globals';
import fc from 'fast-check';
import { Testable } from '@ephox/dispute';
var tNumber = Testable.tNumber, tString = Testable.tString, tArray = Testable.tArray;
promiseTest('Future: pure get', function () {
    return fc.assert(fc.asyncProperty(fc.integer(), function (i) { return new Promise(function (resolve, reject) {
        Future.pure(i).get(function (ii) {
            eqAsync('pure get', i, ii, reject, tNumber);
            resolve();
        });
    }); }));
});
promiseTest('Future: future soon get', function () {
    return fc.assert(fc.asyncProperty(fc.integer(), function (i) { return new Promise(function (resolve, reject) {
        Future.nu(function (cb) {
            setTimeout(function () {
                cb(i);
            }, 3);
        }).get(function (ii) {
            eqAsync('get', i, ii, reject, tNumber);
            resolve();
        });
    }); }));
});
promiseTest('Future: map', function () {
    return fc.assert(fc.asyncProperty(fc.integer(), fc.func(fc.string()), function (i, f) { return new Promise(function (resolve, reject) {
        Future.pure(i).map(f).get(function (ii) {
            eqAsync('get', f(i), ii, reject, tString);
            resolve();
        });
    }); }));
});
promiseTest('Future: bind', function () {
    return fc.assert(fc.asyncProperty(fc.integer(), fc.func(fc.string()), function (i, f) { return new Promise(function (resolve, reject) {
        Future.pure(i).bind(Fun.compose(Future.pure, f)).get(function (ii) {
            eqAsync('get', f(i), ii, reject, tString);
            resolve();
        });
    }); }));
});
promiseTest('Future: anonBind', function () {
    return fc.assert(fc.asyncProperty(fc.integer(), fc.string(), function (i, s) { return new Promise(function (resolve, reject) {
        Future.pure(i).anonBind(Future.pure(s)).get(function (ii) {
            eqAsync('get', s, ii, reject, tString);
            resolve();
        });
    }); }));
});
promiseTest('Future: parallel', function () {
    return new Promise(function (resolve, reject) {
        var f = Future.nu(function (callback) {
            setTimeout(Fun.curry(callback, 'apple'), 10);
        });
        var g = Future.nu(function (callback) {
            setTimeout(Fun.curry(callback, 'banana'), 5);
        });
        var h = Future.nu(function (callback) {
            callback('carrot');
        });
        Futures.par([f, g, h]).get(function (r) {
            eqAsync('r[0]', r[0], 'apple', reject);
            eqAsync('r[1]', r[1], 'banana', reject);
            eqAsync('r[2]', r[2], 'carrot', reject);
            resolve(true);
        });
    });
});
promiseTest('Future: parallel spec', function () {
    return fc.assert(fc.asyncProperty(fc.array(fc.tuple(fc.integer(1, 10), fc.integer())), function (tuples) { return new Promise(function (resolve, reject) {
        Futures.par(Arr.map(tuples, function (_a) {
            var timeout = _a[0], value = _a[1];
            return Future.nu(function (cb) {
                setTimeout(function () {
                    cb(value);
                }, timeout);
            });
        })).get(function (ii) {
            eqAsync('pars', tuples.map(function (_a) {
                var _ = _a[0], i = _a[1];
                return i;
            }), ii, reject, tArray(tNumber));
            resolve();
        });
    }); }));
});
promiseTest('Future: mapM', function () {
    return new Promise(function (resolve, reject) {
        var fn = function (a) {
            return Future.nu(function (cb) {
                setTimeout(Fun.curry(cb, a + ' bizarro'), 10);
            });
        };
        Futures.traverse(['q', 'r', 's'], fn).get(function (r) {
            eqAsync('eq', ['q bizarro', 'r bizarro', 's bizarro'], r, reject);
            resolve();
        });
    });
});
promiseTest('Future: mapM spec', function () {
    return fc.assert(fc.asyncProperty(fc.array(fc.tuple(fc.integer(1, 10), fc.integer())), function (tuples) { return new Promise(function (resolve, reject) {
        Futures.mapM(tuples, function (_a) {
            var timeout = _a[0], value = _a[1];
            return Future.nu(function (cb) {
                setTimeout(function () {
                    cb(value);
                }, timeout);
            });
        }).get(function (ii) {
            eqAsync('pars', tuples.map(function (_a) {
                var _ = _a[0], i = _a[1];
                return i;
            }), ii, reject, tArray(tNumber));
            resolve();
        });
    }); }));
});
promiseTest('Future: compose', function () {
    return new Promise(function (resolve, reject) {
        var f = function (a) {
            return Future.nu(function (cb) {
                setTimeout(Fun.curry(cb, a + ' f'), 10);
            });
        };
        var g = function (a) {
            return Future.nu(function (cb) {
                setTimeout(Fun.curry(cb, a + ' g'), 10);
            });
        };
        Futures.compose(f, g)('a').get(function (r) {
            eqAsync('compose', 'a g f', r, reject);
            resolve(true);
        });
    });
});
promiseTest('Future: cache', function () {
    return new Promise(function (resolve, reject) {
        var callCount = 0;
        var future = Future.nu(function (cb) {
            callCount++;
            setTimeout(Fun.curry(cb, callCount), 10);
        });
        var cachedFuture = future.toCached();
        eqAsync('eq', 0, callCount, reject);
        cachedFuture.get(function (r) {
            eqAsync('eq', 1, r, reject);
            eqAsync('eq', 1, callCount, reject);
            cachedFuture.get(function (r2) {
                eqAsync('eq', 1, r2, reject);
                eqAsync('eq', 1, callCount, reject);
                resolve();
            });
        });
    });
});
//# sourceMappingURL=FutureTest.js.map