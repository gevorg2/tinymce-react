import * as Arr from 'ephox/katamari/api/Arr';
import * as Obj from 'ephox/katamari/api/Obj';
import * as Unique from 'ephox/katamari/api/Unique';
import { MixedBag } from 'ephox/katamari/data/MixedBag';
import fc from 'fast-check';
import { UnitTest, Assert } from '@ephox/bedrock-client';
import { Option } from 'ephox/katamari/api/Option';
import { tOption } from 'ephox/katamari/api/OptionInstances';
UnitTest.test('MixedBag: unit tests', function () {
    var bagger = MixedBag(['alpha', 'beta', 'gamma'], ['oDelta', 'oEpsilon']);
    (function () {
        var t1 = bagger({
            alpha: 'a',
            beta: 'b',
            gamma: 'g'
        });
        Assert.eq('eq', 'a', t1.alpha());
        Assert.eq('eq', 'b', t1.beta());
        Assert.eq('eq', 'g', t1.gamma());
        Assert.eq('eq', Option.none(), t1.oDelta(), tOption());
        Assert.eq('eq', Option.none(), t1.oEpsilon(), tOption());
    })();
    (function () {
        var t1 = bagger({
            alpha: 'a',
            beta: 'b',
            gamma: 'g',
            oDelta: 'd'
        });
        Assert.eq('eq', 'a', t1.alpha());
        Assert.eq('eq', 'b', t1.beta());
        Assert.eq('eq', 'g', t1.gamma());
        Assert.eq('eq', Option.some('d'), t1.oDelta(), tOption());
        Assert.eq('eq', Option.none(), t1.oEpsilon(), tOption());
    })();
    (function () {
        var t1 = bagger({
            alpha: 'a',
            beta: 'b',
            gamma: 'g',
            oDelta: 'd',
            oEpsilon: 'e'
        });
        Assert.eq('eq', 'a', t1.alpha());
        Assert.eq('eq', 'b', t1.beta());
        Assert.eq('eq', 'g', t1.gamma());
        Assert.eq('eq', Option.some('d'), t1.oDelta(), tOption());
        Assert.eq('eq', Option.some('e'), t1.oEpsilon(), tOption());
    })();
    (function () {
        var expected = 'All required keys (alpha, beta, gamma) were not specified. Specified keys were: alpha, gamma, oDelta, oEpsilon.';
        try {
            var t1 = bagger({
                alpha: 'a',
                gamma: 'g',
                oDelta: 'd',
                oEpsilon: 'e'
            });
            Assert.fail('Expected failure.');
        }
        catch (err) {
            Assert.eq('eq', expected, err.message);
        }
    })();
    (function () {
        var t1 = bagger({
            alpha: 'a',
            beta: 'b',
            gamma: undefined,
            oDelta: 'd',
            oEpsilon: 'e'
        });
        Assert.eq('eq', 'a', t1.alpha());
        Assert.eq('eq', 'b', t1.beta());
        Assert.eq('eq', undefined, t1.gamma());
        Assert.eq('eq', Option.some('d'), t1.oDelta(), tOption());
        Assert.eq('eq', Option.some('e'), t1.oEpsilon(), tOption());
    })();
    (function () {
        var t1 = bagger({
            alpha: 'a',
            beta: 'b',
            gamma: undefined,
            oDelta: 'd',
            oEpsilon: undefined
        });
        Assert.eq('eq', 'a', t1.alpha());
        Assert.eq('eq', 'b', t1.beta());
        Assert.eq('eq', undefined, t1.gamma());
        Assert.eq('eq', Option.some('d'), t1.oDelta(), tOption());
        Assert.eq('eq', Option.some(undefined), t1.oEpsilon(), tOption());
    })();
    (function () {
        var expected = 'Unsupported keys for object: ghost';
        try {
            var t1 = bagger({
                alpha: 'a',
                beta: 'b',
                gamma: undefined,
                oDelta: 'd',
                oEpsilon: undefined,
                ghost: 'boo'
            });
            Assert.fail('Expected failure: ' + expected);
        }
        catch (err) {
            Assert.eq('eq', expected, err.message);
        }
    })();
    (function () {
        var expected = 'You must specify at least one required or optional field.';
        try {
            var bg = MixedBag([], []);
            Assert.fail('Expected failure: ' + expected);
        }
        catch (err) {
            Assert.eq('eq', expected, err.message);
        }
    })();
    (function () {
        var expected = 'The value 10 in the required fields was not a string.';
        try {
            var bg = MixedBag([10], []);
            Assert.fail('Expected failure: ' + expected);
        }
        catch (err) {
            Assert.eq('eq', expected, err.message);
        }
    })();
    (function () {
        var expected = 'The value 5 in the optional fields was not a string.';
        try {
            var bg = MixedBag([], [5]);
            Assert.fail('Expected failure: ' + expected);
        }
        catch (err) {
            Assert.eq('eq', expected, err.message);
        }
    })();
    (function () {
        var expected = 'The required fields must be an array. Was: apple.';
        try {
            var bg = MixedBag('apple', [5]);
            Assert.fail('Expected failure: ' + expected);
        }
        catch (err) {
            Assert.eq('eq', expected, err.message);
        }
    })();
    (function () {
        var expected = 'The optional fields must be an array. Was: beetroot.';
        try {
            var bg = MixedBag([], 'beetroot');
            Assert.fail('Expected failure: ' + expected);
        }
        catch (err) {
            Assert.eq('eq', expected, err.message);
        }
    })();
    (function () {
        var expected = 'The field: cat occurs more than once in the combined fields: [apple, cat, cat].';
        try {
            var bg = MixedBag(['cat'], ['apple', 'cat']);
            Assert.fail('Expected failure: ' + expected);
        }
        catch (err) {
            Assert.eq('eq', expected, err.message);
        }
    })();
});
var genInputs = fc.array(fc.string(1, 40)).chain(function (rawRequired) { return fc.array(fc.string(1, 40)).chain(function (rawExtra) {
    var extra = Unique.stringArray(rawExtra);
    return fc.string(1, 40).map(function (backup) {
        var required = rawRequired.length === 0 && extra.length === 0 ? [backup] : Unique.stringArray(rawRequired);
        return {
            required: required,
            extra: Arr.filter(extra, function (e) { return !Arr.contains(required, e); })
        };
    });
}); });
UnitTest.test('MixedBag: properties', function () {
    fc.assert(fc.property(genInputs, fc.json(), fc.func(fc.boolean()), function (inputs, constant, pred) {
        var bag = MixedBag(inputs.required, inputs.extra);
        var fields = Arr.filter(inputs.required.concat(inputs.extra), function (x) { return pred(x); });
        var r = {};
        Arr.each(fields, function (field) {
            r[field] = constant;
        });
        var shouldPass = Arr.forall(inputs.required, function (k) { return r.hasOwnProperty(k); });
        if (shouldPass) {
            var output_1 = bag(r);
            var keys = Obj.keys(output_1);
            return Arr.forall(keys, function (k) { return ((Arr.contains(inputs.required, k) && output_1[k]() === r[k]) ||
                (Arr.contains(inputs.extra, k) && ((r.hasOwnProperty(k) && output_1[k]().isSome()) ||
                    (!r.hasOwnProperty(k) && output_1[k]().isNone())))); });
        }
        else {
            try {
                bag(r);
                return false;
            }
            catch (err) {
                if (err.message.indexOf('All required') > -1) {
                    return true;
                }
                else {
                    Assert.fail('Unexpected error: ' + err.message);
                    return false;
                }
            }
        }
    }));
});
//# sourceMappingURL=MixedBagTest.js.map