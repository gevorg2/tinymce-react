import { __assign } from "tslib";
import { Future } from './Future';
import { Result } from './Result';
import { clearTimeout, setTimeout } from '@ephox/dom-globals';
var wrap = function (delegate) {
    var toCached = function () {
        return wrap(delegate.toCached());
    };
    var bindFuture = function (f) {
        return wrap(delegate.bind(function (resA) { return resA.fold(function (err) { return (Future.pure(Result.error(err))); }, function (a) { return f(a); }); }));
    };
    var bindResult = function (f) {
        return wrap(delegate.map(function (resA) { return resA.bind(f); }));
    };
    var mapResult = function (f) {
        return wrap(delegate.map(function (resA) { return resA.map(f); }));
    };
    var mapError = function (f) {
        return wrap(delegate.map(function (resA) { return resA.mapError(f); }));
    };
    var foldResult = function (whenError, whenValue) {
        return delegate.map(function (res) { return res.fold(whenError, whenValue); });
    };
    var withTimeout = function (timeout, errorThunk) {
        return wrap(Future.nu(function (callback) {
            var timedOut = false;
            var timer = setTimeout(function () {
                timedOut = true;
                callback(Result.error(errorThunk()));
            }, timeout);
            delegate.get(function (result) {
                if (!timedOut) {
                    clearTimeout(timer);
                    callback(result);
                }
            });
        }));
    };
    return __assign(__assign({}, delegate), { toCached: toCached,
        bindFuture: bindFuture,
        bindResult: bindResult,
        mapResult: mapResult,
        mapError: mapError,
        foldResult: foldResult,
        withTimeout: withTimeout });
};
var nu = function (worker) {
    return wrap(Future.nu(worker));
};
var value = function (value) {
    return wrap(Future.pure(Result.value(value)));
};
var error = function (error) {
    return wrap(Future.pure(Result.error(error)));
};
var fromResult = function (result) {
    return wrap(Future.pure(result));
};
var fromFuture = function (future) {
    return wrap(future.map(Result.value));
};
var fromPromise = function (promise) {
    return nu(function (completer) {
        promise.then(function (value) {
            completer(Result.value(value));
        }, function (error) {
            completer(Result.error(error));
        });
    });
};
export var FutureResult = {
    nu: nu,
    wrap: wrap,
    pure: value,
    value: value,
    error: error,
    fromResult: fromResult,
    fromFuture: fromFuture,
    fromPromise: fromPromise
};
//# sourceMappingURL=FutureResult.js.map