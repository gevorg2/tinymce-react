import { Option } from './Option';
import * as Arr from './Arr';
import * as Fun from './Fun';
export var cat = function (arr) {
    var r = [];
    var push = function (x) {
        r.push(x);
    };
    for (var i = 0; i < arr.length; i++) {
        arr[i].each(push);
    }
    return r;
};
export var sequence = function (arr) {
    var r = [];
    for (var i = 0; i < arr.length; i++) {
        var x = arr[i];
        if (x.isSome()) {
            r.push(x.getOrDie());
        }
        else {
            return Option.none();
        }
    }
    return Option.some(r);
};
/** @deprecated Use Arr.findMap instead. */
export var findMap = Arr.findMap;
/** Map each element of an array to an Option and collect the results.
 *  If all results are "some", return Option.some of the results.
 *  If any result is "none", return Option.none
 */
export var traverse = function (arr, f) {
    return sequence(Arr.map(arr, f));
};
/*
Notes on the lift functions:
- We used to have a generic liftN, but we were concerned about its type-safety, and the below variants were faster in microbenchmarks.
- The getOrDie calls are partial functions, but are checked beforehand. This is faster and more convenient (but less safe) than folds.
- && is used instead of a loop for simplicity and performance.
*/
export var lift2 = function (oa, ob, f) {
    return oa.isSome() && ob.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie())) : Option.none();
};
export var lift3 = function (oa, ob, oc, f) {
    return oa.isSome() && ob.isSome() && oc.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Option.none();
};
export var lift4 = function (oa, ob, oc, od, f) {
    return oa.isSome() && ob.isSome() && oc.isSome() && od.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie(), od.getOrDie())) : Option.none();
};
export var lift5 = function (oa, ob, oc, od, oe, f) {
    return oa.isSome() && ob.isSome() && oc.isSome() && od.isSome() && oe.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie(), od.getOrDie(), oe.getOrDie())) : Option.none();
};
export var mapFrom = function (a, f) {
    return (a !== undefined && a !== null) ? Option.some(f(a)) : Option.none();
};
export var bindFrom = function (a, f) {
    return (a !== undefined && a !== null) ? f(a) : Option.none();
};
export var flatten = function (oot) { return oot.bind(Fun.identity); };
// This can help with type inference, by specifying the type param on the none case, so the caller doesn't have to.
export var someIf = function (b, a) {
    return b ? Option.some(a) : Option.none();
};
//# sourceMappingURL=Options.js.map