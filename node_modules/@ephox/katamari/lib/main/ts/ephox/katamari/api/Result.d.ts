import { Option } from './Option';
export interface Result<T, E> {
    is: (value: T) => boolean;
    or: (result: Result<T, E>) => Result<T, E>;
    orThunk: (makeResult: () => Result<T, E>) => Result<T, E>;
    map: <U>(mapper: (value: T) => U) => Result<U, E>;
    mapError: <U>(mapper: (err: E) => U) => Result<T, U>;
    each: (worker: (value: T) => void) => void;
    bind: <U>(binder: (value: T) => Result<U, E>) => Result<U, E>;
    fold: <U>(whenError: (err: E) => U, mapper: (value: T) => U) => U;
    exists: (predicate: (value: T) => boolean) => boolean;
    forall: (predicate: (value: T) => boolean) => boolean;
    toOption: () => Option<T>;
    isValue: () => boolean;
    isError: () => boolean;
    getOr: (defaultValue: T) => T;
    getOrThunk: (maker: () => T) => T;
    getOrDie: () => T;
}
export declare const Result: {
    value: <T, E = any>(o: T) => Result<T, E>;
    error: <T_1 = any, E_1 = any>(message: E_1) => Result<T_1, E_1>;
    fromOption: <T_2, E_2>(opt: Option<T_2>, err: E_2) => Result<T_2, E_2>;
};
//# sourceMappingURL=Result.d.ts.map