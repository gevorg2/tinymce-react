import { setTimeout } from '@ephox/dom-globals';
import Promise from '@ephox/wrap-promise-polyfill';
import { LazyValue } from './LazyValue';
var errorReporter = function (err) {
    // we can not throw the error in the reporter as it will just be black-holed
    // by the Promise so we use a setTimeout to escape the Promise.
    setTimeout(function () {
        throw err;
    }, 0);
};
var make = function (run) {
    var get = function (callback) {
        run().then(callback, errorReporter);
    };
    /** map :: this Future a -> (a -> b) -> Future b */
    var map = function (fab) {
        return make(function () { return run().then(fab); });
    };
    /** bind :: this Future a -> (a -> Future b) -> Future b */
    var bind = function (aFutureB) {
        return make(function () { return run().then(function (v) { return aFutureB(v).toPromise(); }); });
    };
    /** anonBind :: this Future a -> Future b -> Future b
     *  Returns a future, which evaluates the first future, ignores the result, then evaluates the second.
     */
    var anonBind = function (futureB) {
        return make(function () { return run().then(function () { return futureB.toPromise(); }); });
    };
    var toLazy = function () {
        return LazyValue.nu(get);
    };
    var toCached = function () {
        var cache = null;
        return make(function () {
            if (cache === null) {
                cache = run();
            }
            return cache;
        });
    };
    var toPromise = run;
    return {
        map: map,
        bind: bind,
        anonBind: anonBind,
        toLazy: toLazy,
        toCached: toCached,
        toPromise: toPromise,
        get: get
    };
};
var nu = function (baseFn) {
    return make(function () { return new Promise(baseFn); });
};
/** a -> Future a */
var pure = function (a) {
    return make(function () { return Promise.resolve(a); });
};
export var Future = {
    nu: nu,
    pure: pure
};
//# sourceMappingURL=Future.js.map