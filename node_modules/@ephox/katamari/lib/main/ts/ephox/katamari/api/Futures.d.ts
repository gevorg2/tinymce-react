import { Future } from './Future';
export declare const par: <T>(futures: ArrayLike<Future<T>>) => Future<T[]>;
export declare const traverse: <A, B>(array: ArrayLike<A>, fn: (value: A) => Future<B>) => Future<B[]>;
/** Deprecated for rename to traverse */
export declare const mapM: <A, B>(array: ArrayLike<A>, fn: (value: A) => Future<B>) => Future<B[]>;
/** Kleisli composition of two functions: a -> Future b.
 *  Note the order of arguments: g is invoked first, then the result passed to f.
 *  This is in line with f . g = \x -> f (g a)
 *
 *  compose :: ((b -> Future c), (a -> Future b)) -> a -> Future c
 */
export declare const compose: <A, B, C>(f: (b: B) => Future<C>, g: (a: A) => Future<B>) => (a: A) => Future<C>;
//# sourceMappingURL=Futures.d.ts.map