import { Option } from './Option';
export declare const cat: <A>(arr: Option<A>[]) => A[];
export declare const sequence: <A>(arr: ArrayLike<Option<A>>) => Option<A[]>;
/** @deprecated Use Arr.findMap instead. */
export declare const findMap: <A, B>(arr: ArrayLike<A>, f: (a: A, index: number) => Option<B>) => Option<B>;
/** Map each element of an array to an Option and collect the results.
 *  If all results are "some", return Option.some of the results.
 *  If any result is "none", return Option.none
 */
export declare const traverse: <A, B>(arr: ArrayLike<A>, f: (a: A) => Option<B>) => Option<B[]>;
export declare const lift2: <A, B, C>(oa: Option<A>, ob: Option<B>, f: (a: A, b: B) => C) => Option<C>;
export declare const lift3: <A, B, C, D>(oa: Option<A>, ob: Option<B>, oc: Option<C>, f: (a: A, b: B, c: C) => D) => Option<D>;
export declare const lift4: <A, B, C, D, E>(oa: Option<A>, ob: Option<B>, oc: Option<C>, od: Option<D>, f: (a: A, b: B, c: C, d: D) => E) => Option<E>;
export declare const lift5: <A, B, C, D, E, F>(oa: Option<A>, ob: Option<B>, oc: Option<C>, od: Option<D>, oe: Option<E>, f: (a: A, b: B, c: C, d: D, e: E) => F) => Option<F>;
export declare const mapFrom: <A, B>(a: A | null | undefined, f: (a: A) => B) => Option<B>;
export declare const bindFrom: <A, B>(a: A | null | undefined, f: (a: A) => Option<B>) => Option<B>;
export declare const flatten: <T>(oot: Option<Option<T>>) => Option<T>;
export declare const someIf: <A>(b: boolean, a: A) => Option<A>;
//# sourceMappingURL=Options.d.ts.map