import { Option } from './Option';
import * as Type from './Type';
import { Eq } from '@ephox/dispute';
var nativeSlice = Array.prototype.slice;
var nativeIndexOf = Array.prototype.indexOf;
var nativePush = Array.prototype.push;
var rawIndexOf = function (ts, t) {
    return nativeIndexOf.call(ts, t);
};
export var indexOf = function (xs, x) {
    // The rawIndexOf method does not wrap up in an option. This is for performance reasons.
    var r = rawIndexOf(xs, x);
    return r === -1 ? Option.none() : Option.some(r);
};
export var contains = function (xs, x) {
    return rawIndexOf(xs, x) > -1;
};
export var exists = function (xs, pred) {
    for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
            return true;
        }
    }
    return false;
};
export var range = function (num, f) {
    var r = [];
    for (var i = 0; i < num; i++) {
        r.push(f(i));
    }
    return r;
};
// It's a total micro optimisation, but these do make some difference.
// Particularly for browsers other than Chrome.
// - length caching
// http://jsperf.com/browser-diet-jquery-each-vs-for-loop/69
// - not using push
// http://jsperf.com/array-direct-assignment-vs-push/2
export var chunk = function (array, size) {
    var r = [];
    for (var i = 0; i < array.length; i += size) {
        var s = nativeSlice.call(array, i, i + size);
        r.push(s);
    }
    return r;
};
export var map = function (xs, f) {
    // pre-allocating array size when it's guaranteed to be known
    // http://jsperf.com/push-allocated-vs-dynamic/22
    var len = xs.length;
    var r = new Array(len);
    for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
    }
    return r;
};
// Unwound implementing other functions in terms of each.
// The code size is roughly the same, and it should allow for better optimisation.
// const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {
export var each = function (xs, f) {
    for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        f(x, i);
    }
};
export var eachr = function (xs, f) {
    for (var i = xs.length - 1; i >= 0; i--) {
        var x = xs[i];
        f(x, i);
    }
};
export var partition = function (xs, pred) {
    var pass = [];
    var fail = [];
    for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        var arr = pred(x, i) ? pass : fail;
        arr.push(x);
    }
    return { pass: pass, fail: fail };
};
export var filter = function (xs, pred) {
    var r = [];
    for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
            r.push(x);
        }
    }
    return r;
};
/*
 * Groups an array into contiguous arrays of like elements. Whether an element is like or not depends on f.
 *
 * f is a function that derives a value from an element - e.g. true or false, or a string.
 * Elements are like if this function generates the same value for them (according to ===).
 *
 *
 * Order of the elements is preserved. Arr.flatten() on the result will return the original list, as with Haskell groupBy function.
 *  For a good explanation, see the group function (which is a special case of groupBy)
 *  http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:group
 */
export var groupBy = function (xs, f) {
    if (xs.length === 0) {
        return [];
    }
    else {
        var wasType = f(xs[0]); // initial case for matching
        var r = [];
        var group = [];
        for (var i = 0, len = xs.length; i < len; i++) {
            var x = xs[i];
            var type = f(x);
            if (type !== wasType) {
                r.push(group);
                group = [];
            }
            wasType = type;
            group.push(x);
        }
        if (group.length !== 0) {
            r.push(group);
        }
        return r;
    }
};
export var foldr = function (xs, f, acc) {
    eachr(xs, function (x) {
        acc = f(acc, x);
    });
    return acc;
};
export var foldl = function (xs, f, acc) {
    each(xs, function (x) {
        acc = f(acc, x);
    });
    return acc;
};
export var find = function (xs, pred) {
    for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
            return Option.some(x);
        }
    }
    return Option.none();
};
export var findIndex = function (xs, pred) {
    for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
            return Option.some(i);
        }
    }
    return Option.none();
};
export var flatten = function (xs) {
    // Note, this is possible because push supports multiple arguments:
    // http://jsperf.com/concat-push/6
    // Note that in the past, concat() would silently work (very slowly) for array-like objects.
    // With this change it will throw an error.
    var r = [];
    for (var i = 0, len = xs.length; i < len; ++i) {
        // Ensure that each value is an array itself
        if (!Type.isArray(xs[i])) {
            throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
    }
    return r;
};
export var bind = function (xs, f) {
    return flatten(map(xs, f));
};
export var forall = function (xs, pred) {
    for (var i = 0, len = xs.length; i < len; ++i) {
        var x = xs[i];
        if (pred(x, i) !== true) {
            return false;
        }
    }
    return true;
};
export var equal = function (a1, a2, eq) {
    if (eq === void 0) { eq = Eq.eqAny; }
    return Eq.eqArray(eq).eq(a1, a2);
};
export var reverse = function (xs) {
    var r = nativeSlice.call(xs, 0);
    r.reverse();
    return r;
};
export var difference = function (a1, a2) {
    return filter(a1, function (x) { return !contains(a2, x); });
};
export var mapToObject = function (xs, f) {
    var r = {};
    for (var i = 0, len = xs.length; i < len; i++) {
        var x = xs[i];
        r[String(x)] = f(x, i);
    }
    return r;
};
export var pure = function (x) { return [x]; };
export var sort = function (xs, comparator) {
    var copy = nativeSlice.call(xs, 0);
    copy.sort(comparator);
    return copy;
};
export var head = function (xs) { return xs.length === 0 ? Option.none() : Option.some(xs[0]); };
export var last = function (xs) { return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]); };
export var from = Type.isFunction(Array.from) ? Array.from : function (x) { return nativeSlice.call(x); };
export var findMap = function (arr, f) {
    for (var i = 0; i < arr.length; i++) {
        var r = f(arr[i], i);
        if (r.isSome()) {
            return r;
        }
    }
    return Option.none();
};
//# sourceMappingURL=Arr.js.map