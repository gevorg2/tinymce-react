import { Option } from './Option';
import { Eq } from '@ephox/dispute';
declare type ArrayMorphism<T, U> = (x: T, i: number) => U;
declare type ArrayPredicate<T> = ArrayMorphism<T, boolean>;
declare type Comparator<T> = (a: T, b: T) => number;
export declare const indexOf: <T = any>(xs: ArrayLike<T>, x: T) => Option<number>;
export declare const contains: <T>(xs: ArrayLike<T>, x: T) => boolean;
export declare const exists: <T = any>(xs: ArrayLike<T>, pred: ArrayMorphism<T, boolean>) => boolean;
export declare const range: <T>(num: number, f: (a: number) => T) => T[];
export declare const chunk: <T>(array: ArrayLike<T>, size: number) => T[][];
export declare const map: <T = any, U = any>(xs: ArrayLike<T>, f: ArrayMorphism<T, U>) => U[];
export declare const each: <T = any>(xs: ArrayLike<T>, f: ArrayMorphism<T, void>) => void;
export declare const eachr: <T>(xs: ArrayLike<T>, f: ArrayMorphism<T, void>) => void;
export declare const partition: <T = any>(xs: ArrayLike<T>, pred: ArrayMorphism<T, boolean>) => {
    pass: T[];
    fail: T[];
};
export declare const filter: {
    <T, Q extends T>(xs: ArrayLike<T>, pred: (x: T, i: number) => x is Q): Q[];
    <T>(xs: ArrayLike<T>, pred: ArrayPredicate<T>): T[];
};
export declare const groupBy: <T>(xs: ArrayLike<T>, f: (a: T) => any) => T[][];
export declare const foldr: <T, U>(xs: ArrayLike<T>, f: (acc: U, x: T) => U, acc: U) => U;
export declare const foldl: <T = any, U = any>(xs: ArrayLike<T>, f: (acc: U, x: T) => U, acc: U) => U;
export declare const find: <T = any>(xs: ArrayLike<T>, pred: ArrayMorphism<T, boolean>) => Option<T>;
export declare const findIndex: <T>(xs: ArrayLike<T>, pred: ArrayMorphism<T, boolean>) => Option<number>;
export declare const flatten: <T>(xs: ArrayLike<T[]>) => T[];
export declare const bind: <T = any, U = any>(xs: ArrayLike<T>, f: ArrayMorphism<T, U[]>) => U[];
export declare const forall: <T>(xs: ArrayLike<T>, pred: ArrayMorphism<T, boolean>) => boolean;
export declare const equal: <T>(a1: ArrayLike<T>, a2: ArrayLike<T>, eq?: Eq.Eq<T>) => boolean;
export declare const reverse: <T>(xs: ArrayLike<T>) => T[];
export declare const difference: <T>(a1: ArrayLike<T>, a2: ArrayLike<T>) => T[];
export declare const mapToObject: <T extends string | number | symbol, U>(xs: ArrayLike<T>, f: (x: T, i: number) => U) => Record<T, U>;
export declare const pure: <T>(x: T) => T[];
export declare const sort: <T>(xs: ArrayLike<T>, comparator?: Comparator<T> | undefined) => T[];
export declare const head: <T>(xs: ArrayLike<T>) => Option<T>;
export declare const last: <T>(xs: ArrayLike<T>) => Option<T>;
export declare const from: <T>(x: ArrayLike<T>) => T[];
export declare const findMap: <A, B>(arr: ArrayLike<A>, f: (a: A, index: number) => Option<B>) => Option<B>;
export {};
//# sourceMappingURL=Arr.d.ts.map