import { Future } from './Future';
import { Result } from './Result';
export interface FutureResult<A, E> extends Future<Result<A, E>> {
    toCached: () => FutureResult<A, E>;
    bindFuture: <B>(f: (value: A) => Future<Result<B, E>>) => FutureResult<B, E>;
    bindResult: <B>(f: (value: A) => Result<B, E>) => FutureResult<B, E>;
    mapResult: <B>(f: (value: A) => B) => FutureResult<B, E>;
    mapError: <B>(f: (error: E) => B) => FutureResult<A, B>;
    foldResult: <X>(whenError: (error: E) => X, whenValue: (value: A) => X) => Future<X>;
    withTimeout: (timeout: number, errorThunk: () => E) => FutureResult<A, E>;
}
export declare const FutureResult: {
    nu: <A = any, E = any>(worker: (completer: (result: Result<A, E>) => void) => void) => FutureResult<A, E>;
    wrap: <A_1 = any, E_1 = any>(delegate: Future<Result<A_1, E_1>>) => FutureResult<A_1, E_1>;
    pure: <A_2, E_2 = any>(value: A_2) => FutureResult<A_2, any>;
    value: <A_2, E_2 = any>(value: A_2) => FutureResult<A_2, any>;
    error: <A_3 = any, E_3 = any>(error: E_3) => FutureResult<any, E_3>;
    fromResult: <A_4, E_4>(result: Result<A_4, E_4>) => FutureResult<A_4, E_4>;
    fromFuture: <A_5, E_5 = any>(future: Future<A_5>) => FutureResult<A_5, any>;
    fromPromise: <T, E_6 = any>(promise: Promise<T>) => FutureResult<T, E_6>;
};
//# sourceMappingURL=FutureResult.d.ts.map