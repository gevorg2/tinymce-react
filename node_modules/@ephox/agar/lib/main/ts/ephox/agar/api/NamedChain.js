import { __assign } from "tslib";
import { Arr, Id } from '@ephox/katamari';
import { Chain } from './Chain';
var inputNameId = Id.generate('input-name');
var outputNameId = Id.generate('output-name');
var outputUnset = Id.generate('output-unset');
var asChain = function (chains) {
    return Chain.fromChains(Arr.flatten([
        [Chain.mapper(function (input) {
                var _a;
                return (_a = {},
                    _a[inputNameId] = input,
                    _a[outputNameId] = outputUnset,
                    _a);
            })],
        chains,
        [Chain.mapper(function (data) {
                var output = data[outputNameId];
                delete data[outputNameId];
                return output === outputUnset ? data : output;
            })]
    ]));
};
// Write merges in its output into input because it knows that it was
// given a complete input.
var write = function (name, chain) {
    return Chain.on(function (input, next, die, initLogs) {
        chain.runChain(input, function (output, newLogs) {
            var self = wrapSingle(name, output);
            return next(__assign(__assign({}, input), self), newLogs);
        }, die, initLogs);
    });
};
// Partial write does not try and merge in input, because it knows that it
// might not be getting the full input
var partialWrite = function (name, chain) {
    return Chain.on(function (input, next, die, initLogs) {
        chain.runChain(input, function (output, newLogs) {
            var self = wrapSingle(name, output);
            return next(self, newLogs);
        }, die, initLogs);
    });
};
var wrapSingle = function (name, value) {
    var _a;
    if (name === '_') {
        return {};
    }
    return _a = {},
        _a[name] = value,
        _a;
};
var combine = function (input, name, value) { return (__assign(__assign({}, input), wrapSingle(name, value))); };
var process = function (name, chain) {
    return Chain.on(function (input, next, die, initLogs) {
        if (Object.prototype.hasOwnProperty.call(input, name)) {
            var part = input[name];
            chain.runChain(part, function (other, newLogs) {
                var merged = __assign(__assign({}, input), other);
                next(merged, newLogs);
            }, die, initLogs);
        }
        else {
            die(name + ' is not a field in the index object.', initLogs);
        }
    });
};
var direct = function (inputName, chain, outputName) {
    return process(inputName, partialWrite(outputName, chain));
};
var overwrite = function (inputName, chain) {
    return direct(inputName, chain, inputName);
};
var writeValue = function (name, value) {
    return Chain.mapper(function (input) { return combine(input, name, value); });
};
var read = function (name, chain) {
    return Chain.on(function (input, next, die, initLogs) {
        chain.runChain(input[name], function (_, newLogs) {
            return next(input, newLogs);
        }, die, initLogs);
    });
};
var merge = function (names, combinedName) {
    return Chain.mapper(function (input) {
        var r = {};
        Arr.each(names, function (name) {
            r[name] = input[name];
        });
        return combine(input, combinedName, r);
    });
};
var bundle = function (f) {
    return write(outputNameId, Chain.binder(f));
};
var output = function (name) {
    return direct(name, Chain.identity, outputNameId);
};
var outputInput = output(inputNameId);
var pipeline = function (namedChains, onSuccess, onFailure, initLogs) {
    Chain.pipeline([asChain(namedChains)], onSuccess, onFailure, initLogs);
};
var inputName = function () { return inputNameId; };
// tests need these values but other users should not
export var _outputName = function () { return outputNameId; };
export var _outputUnset = function () { return outputUnset; };
export var NamedChain = {
    inputName: inputName,
    asChain: asChain,
    write: write,
    direct: direct,
    writeValue: writeValue,
    overwrite: overwrite,
    read: read,
    merge: merge,
    bundle: bundle,
    output: output,
    outputInput: outputInput,
    pipeline: pipeline
};
//# sourceMappingURL=NamedChain.js.map