import { Assert, assert } from '@ephox/bedrock-client';
import { Arr, Fun, Obj, Option } from '@ephox/katamari';
import { Attr, Classes, Css, Html, Node, Text, Traverse, Value, Truncate } from '@ephox/sugar';
import * as ApproxComparisons from './ApproxComparisons';
var elementQueue = function (items, container) {
    var i = -1;
    var context = function () {
        return container.fold(function () {
            return '\nItem[' + i + ']:' +
                (i >= 0 && i < items.length ? '\n' + Truncate.getHtml(items[i]) : ' *missing*') +
                '\nComplete Structure:\n' + Arr.map(items, Html.getOuter).join('');
        }, function (element) {
            return '\nContainer:\n' + Truncate.getHtml(element) +
                '\nItem[' + i + ']:' +
                (i >= 0 && i < items.length ? '\n' + Truncate.getHtml(items[i]) : ' *missing*') +
                '\nComplete Structure:\n' + Html.getOuter(element);
        });
    };
    var current = function () { return i >= 0 && i < items.length ? Option.some(items[i]) : Option.none(); };
    var peek = function () { return i + 1 < items.length ? Option.some(items[i + 1]) : Option.none(); };
    var take = function () {
        i += 1;
        return current();
    };
    var mark = function () {
        var x = i;
        var reset = function () {
            i = x;
        };
        var atMark = function () { return i === x; };
        return {
            reset: reset,
            atMark: atMark,
        };
    };
    return {
        context: context,
        current: current,
        peek: peek,
        take: take,
        mark: mark,
    };
};
var element = function (tag, fields) {
    var doAssert = function (actual) {
        Assert.eq(function () { return 'Incorrect node name for: ' + Truncate.getHtml(actual); }, tag, Node.name(actual));
        var attrs = fields.attrs !== undefined ? fields.attrs : {};
        var classes = fields.classes !== undefined ? fields.classes : [];
        var styles = fields.styles !== undefined ? fields.styles : {};
        var html = fields.html !== undefined ? Option.some(fields.html) : Option.none();
        var value = fields.value !== undefined ? Option.some(fields.value) : Option.none();
        var children = fields.children !== undefined ? Option.some(fields.children) : Option.none();
        assertAttrs(attrs, actual);
        assertClasses(classes, actual);
        assertStyles(styles, actual);
        assertHtml(html, actual);
        assertValue(value, actual);
        assertChildren(children, actual);
    };
    return {
        doAssert: doAssert
    };
};
var text = function (s, combineSiblings) {
    if (combineSiblings === void 0) { combineSiblings = false; }
    var doAssert = function (queue) {
        queue.take().fold(function () {
            assert.fail('No more nodes, so cannot check if its text is: ' + s.show() + ' for ' + queue.context());
        }, function (actual) {
            Text.getOption(actual).fold(function () {
                assert.fail('Node is not a text node, so cannot check if its text is: ' + s.show() + ' for ' + queue.context());
            }, function (t) {
                var text = t;
                if (combineSiblings) {
                    while (queue.peek().map(Node.isText).is(true)) {
                        text += queue.take().bind(Text.getOption).getOr('');
                    }
                }
                if (s.strAssert === undefined) {
                    throw new Error(JSON.stringify(s) + ' is not a *string assertion*');
                }
                s.strAssert('Checking text content', text);
            });
        });
    };
    return {
        type: 'advanced',
        doAssert: doAssert
    };
};
var applyAssert = function (structAssert, queue) {
    if (structAssert.type === 'advanced') {
        structAssert.doAssert(queue);
    }
    else {
        queue.take().fold(function () {
            assert.fail('Expected more children to satisfy assertion for ' + queue.context());
        }, function (item) {
            structAssert.doAssert(item);
        });
    }
};
var either = function (structAsserts) {
    var doAssert = function (queue) {
        var mark = queue.mark();
        for (var i = 0; i < structAsserts.length - 1; i++) {
            try {
                applyAssert(structAsserts[i], queue);
                return;
            }
            catch (e) {
                mark.reset();
            }
        }
        if (structAsserts.length > 0) {
            applyAssert(structAsserts[structAsserts.length - 1], queue);
        }
    };
    return {
        type: 'advanced',
        doAssert: doAssert
    };
};
var repeat = function (min, max) {
    if (max === void 0) { max = min; }
    return function (structAssert) {
        var doAssert = function (queue) {
            var i = 0;
            for (; i < min; i++) {
                applyAssert(structAssert, queue);
            }
            for (; (max === true || i < max) && queue.peek().isSome(); i++) {
                var mark = queue.mark();
                try {
                    applyAssert(structAssert, queue);
                }
                catch (e) {
                    mark.reset();
                }
                if (mark.atMark()) {
                    break;
                }
            }
        };
        return {
            type: 'advanced',
            doAssert: doAssert
        };
    };
};
var zeroOrOne = repeat(0, 1);
var zeroOrMore = repeat(0, true);
var oneOrMore = repeat(1, true);
var anythingStruct = {
    doAssert: Fun.noop
};
var assertAttrs = function (expectedAttrs, actual) {
    Obj.each(expectedAttrs, function (v, k) {
        if (v.strAssert === undefined) {
            throw new Error(JSON.stringify(v) + ' is not a *string assertion*.\nSpecified in *expected* attributes of ' + Truncate.getHtml(actual));
        }
        var actualValue = Attr.has(actual, k) ? Attr.get(actual, k) : ApproxComparisons.missing();
        v.strAssert(function () { return 'Checking attribute: "' + k + '" of ' + Truncate.getHtml(actual) + '\n'; }, actualValue);
    });
};
var assertClasses = function (expectedClasses, actual) {
    var actualClasses = Classes.get(actual);
    Arr.each(expectedClasses, function (eCls) {
        if (eCls.arrAssert === undefined) {
            throw new Error(JSON.stringify(eCls) + ' is not an *array assertion*.\nSpecified in *expected* classes of ' + Truncate.getHtml(actual));
        }
        eCls.arrAssert(function () { return 'Checking classes in ' + Truncate.getHtml(actual) + '\n'; }, actualClasses);
    });
};
var assertStyles = function (expectedStyles, actual) {
    Obj.each(expectedStyles, function (v, k) {
        var actualValue = Css.getRaw(actual, k).getOrThunk(ApproxComparisons.missing);
        if (v.strAssert === undefined) {
            throw new Error(JSON.stringify(v) + ' is not a *string assertion*.\nSpecified in *expected* styles of ' + Truncate.getHtml(actual));
        }
        v.strAssert(function () { return 'Checking style: "' + k + '" of ' + Truncate.getHtml(actual) + '\n'; }, actualValue);
    });
};
var assertHtml = function (expectedHtml, actual) {
    expectedHtml.each(function (expected) {
        var actualHtml = Html.get(actual);
        if (expected.strAssert === undefined) {
            throw new Error(JSON.stringify(expected) + ' is not a *string assertion*.\nSpecified in *expected* innerHTML of ' + Truncate.getHtml(actual));
        }
        expected.strAssert(function () { return 'Checking HTML of ' + Truncate.getHtml(actual); }, actualHtml);
    });
};
var assertValue = function (expectedValue, actual) {
    expectedValue.each(function (v) {
        if (v.strAssert === undefined) {
            throw new Error(JSON.stringify(v) + ' is not a *string assertion*.\nSpecified in *expected* value of ' + Truncate.getHtml(actual));
        }
        v.strAssert(function () { return 'Checking value of ' + Truncate.getHtml(actual); }, Value.get(actual));
    });
};
var assertChildren = function (expectedChildren, actual) {
    expectedChildren.each(function (expected) {
        var children = elementQueue(Traverse.children(actual), Option.some(actual));
        Arr.each(expected, function (structExpectation, i) {
            if (structExpectation.doAssert === undefined) {
                throw new Error(JSON.stringify(structExpectation) + ' is not a *structure assertion*.\n' +
                    'Specified in *expected* children of ' + Truncate.getHtml(actual));
            }
            if (structExpectation.type === 'advanced') {
                structExpectation.doAssert(children);
            }
            else {
                children.take().fold(function () {
                    assert.fail('Expected more children to satisfy assertion ' + i + ' for ' + children.context());
                }, function (item) {
                    structExpectation.doAssert(item);
                });
            }
        });
        if (children.peek().isSome()) {
            assert.fail('More children than expected for ' + children.context());
        }
    });
};
var anything = Fun.constant(anythingStruct);
var theRest = Fun.constant(zeroOrMore(anythingStruct));
export { elementQueue, anything, element, text, either, repeat, zeroOrOne, zeroOrMore, oneOrMore, theRest, };
//# sourceMappingURL=ApproxStructures.js.map