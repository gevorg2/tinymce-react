import { clearTimeout, setTimeout } from '@ephox/dom-globals';
import * as ErrorTypes from '../alien/ErrorTypes';
import * as Logger from './Logger';
import { addLogEntry } from './TestLogs';
var defaultInterval = 10;
var defaultAmount = 3000;
var tryUntilNot = function (label, interval, amount) {
    if (interval === void 0) { interval = defaultInterval; }
    if (amount === void 0) { amount = defaultAmount; }
    return function (f, value, next, die, logs) {
        var repeat = function (startTime) {
            f(value, function (v, newLogs) {
                var elapsed = Date.now() - startTime;
                if (elapsed >= amount) {
                    die(new Error('Waited for ' + amount + 'ms for something to be unsuccessful. ' + label), addLogEntry(newLogs, 'WaitErr: ' + label + ' = Failed (after ' + amount + 'ms)'));
                }
                else {
                    setTimeout(function () {
                        repeat(startTime);
                    }, interval);
                }
            }, function (err, newLogs) {
                // Note, this one is fairly experimental.
                // Because errors cause die as well, this is not always the best option.
                // What we do is check to see if it is an error prototype.
                if (Error.prototype.isPrototypeOf(err)) {
                    die(err, newLogs);
                }
                else {
                    next(value, addLogEntry(newLogs, 'WaitErr: ' + label + ' = SUCCESS!'));
                }
            }, logs);
        };
        repeat(Date.now());
    };
};
var tryUntil = function (label, interval, amount) {
    if (interval === void 0) { interval = defaultInterval; }
    if (amount === void 0) { amount = defaultAmount; }
    return function (f, value, next, die, logs) {
        var repeat = function (startTime) {
            f(value, function (v, newLogs) {
                next(v, addLogEntry(newLogs, 'Wait: ' + label + ' = SUCCESS!'));
            }, function (err, newLogs) {
                var elapsed = Date.now() - startTime;
                if (elapsed >= amount) {
                    die(ErrorTypes.enrichWith('Waited for ' + amount + 'ms for something to be successful. ' + label, err), addLogEntry(newLogs, 'Wait: ' + label + ' = FAILED (after ' + amount + 'ms)'));
                }
                else {
                    setTimeout(function () {
                        repeat(startTime);
                    }, interval);
                }
            }, logs);
        };
        repeat(Date.now());
    };
};
var timeout = function (label, limit) {
    return function (f, value, next, die, logs) {
        var passed = false;
        var failed = false;
        var hasNotExited = function () { return passed === false && failed === false; };
        var timer = setTimeout(function () {
            if (hasNotExited()) {
                failed = true;
                die('Hit the limit (' + limit + ') for: ' + label, logs);
            }
        }, limit);
        f(value, function (v, newLogs) {
            clearTimeout(timer);
            if (hasNotExited()) {
                passed = true;
                next(v, newLogs);
            }
        }, function (err, newLogs) {
            if (hasNotExited()) {
                failed = true;
                die(err, newLogs);
            }
        }, logs);
    };
};
var addLogging = function (label) {
    return function (f, value, next, die, logs) {
        return Logger.t(label, { runStep: f }).runStep(value, next, die, logs);
    };
};
export { timeout, tryUntil, tryUntilNot, addLogging };
//# sourceMappingURL=Guard.js.map