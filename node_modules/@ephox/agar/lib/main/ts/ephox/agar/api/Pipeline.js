import { console } from '@ephox/dom-globals';
import { Arr, Type } from '@ephox/katamari';
import { TestLogs } from './TestLogs';
var assertSteps = function (steps) {
    Arr.each(steps, function (s, i) {
        var msg;
        if (s === undefined) {
            msg = 'step ' + i + ' was undefined. All steps: ' + JSON.stringify(steps) + '\n';
        }
        else if (Type.isArray(s)) {
            msg = 'step ' + i + ' was an array';
        }
        if (msg !== undefined) {
            // tslint:disable-next-line:no-console
            console.trace(msg, steps);
            throw new Error(msg);
        }
    });
};
/**
 * Execute a Step, supplying default logs.
 *
 * If you need to run a sequence of steps, compose them using the functions in StepSequence
 */
var runStep = function (initial, step, onSuccess, onFailure, initLogs) {
    step.runStep(initial, onSuccess, onFailure, TestLogs.getOrInit(initLogs));
};
/**
 * @deprecated Use runStep instead
 * TODO: Remove
 */
var async = function (initial, steps, onSuccess, onFailure, initLogs) {
    assertSteps(steps);
    var chain = function (lastLink, logs, index) {
        if (index < steps.length) {
            var asyncOperation = steps[index];
            // FIX: Make this test elsewhere without creating a circular dependency on Chain
            if ('runChain' in asyncOperation) {
                return onFailure('You cannot create a pipeline out of chains. Use Chain.asStep to turns chains into steps', logs);
            }
            try {
                var nextStep_1 = function (result, newLogs) {
                    chain(result, newLogs, index + 1);
                };
                asyncOperation.runStep(lastLink, function (x, newLogs) {
                    nextStep_1(x, newLogs);
                }, onFailure, logs);
            }
            catch (error) {
                onFailure(error, logs);
            }
        }
        else {
            var finalLogs = logs;
            onSuccess(lastLink, finalLogs);
        }
    };
    var startLogs = TestLogs.getOrInit(initLogs);
    chain(initial, startLogs, 0);
};
export var Pipeline = {
    async: async,
    runStep: runStep
};
//# sourceMappingURL=Pipeline.js.map