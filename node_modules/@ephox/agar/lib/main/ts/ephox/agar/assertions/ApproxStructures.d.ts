import { TestLabel } from '@ephox/bedrock-client';
import { Option } from '@ephox/katamari';
import { Element } from '@ephox/sugar';
export interface StringAssert {
    show: () => void;
    strAssert: (label: TestLabel, actual: string) => void;
}
export interface ArrayAssert {
    show: () => void;
    arrAssert: (label: TestLabel, array: any[]) => void;
}
export interface ElementQueue {
    context(): string;
    current(): Option<Element<any>>;
    peek(): Option<Element<any>>;
    take(): Option<Element<any>>;
    mark(): {
        reset: () => void;
        atMark: () => boolean;
    };
}
export interface StructAssertBasic {
    type?: 'basic';
    doAssert: (actual: Element<any>) => void;
}
export interface StructAssertAdv {
    type: 'advanced';
    doAssert: (queue: ElementQueue) => void;
}
export declare type StructAssert = StructAssertBasic | StructAssertAdv;
export interface ElementFields {
    attrs?: Record<string, StringAssert>;
    classes?: ArrayAssert[];
    styles?: Record<string, StringAssert>;
    html?: StringAssert;
    value?: StringAssert;
    children?: StructAssert[];
}
declare const elementQueue: (items: Element<any>[], container: Option<Element<any>>) => ElementQueue;
declare const element: (tag: string, fields: ElementFields) => StructAssert;
declare const text: (s: StringAssert, combineSiblings?: boolean) => StructAssert;
declare const either: (structAsserts: StructAssert[]) => StructAssert;
declare const repeat: (min: number, max?: number | true) => (structAssert: StructAssert) => StructAssert;
declare const zeroOrOne: (structAssert: StructAssert) => StructAssert;
declare const zeroOrMore: (structAssert: StructAssert) => StructAssert;
declare const oneOrMore: (structAssert: StructAssert) => StructAssert;
declare const anything: () => StructAssertBasic;
declare const theRest: () => StructAssert;
export { elementQueue, anything, element, text, either, repeat, zeroOrOne, zeroOrMore, oneOrMore, theRest, };
//# sourceMappingURL=ApproxStructures.d.ts.map