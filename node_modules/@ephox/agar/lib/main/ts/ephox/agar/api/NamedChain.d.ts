import { Result } from '@ephox/katamari';
import { DieFn, NextFn } from '../pipe/Pipe';
import { Chain } from './Chain';
import { TestLogs } from './TestLogs';
export declare type NamedData = Record<string, any>;
export declare type NamedChain = Chain<NamedData, NamedData>;
export declare const _outputName: () => string;
export declare const _outputUnset: () => string;
export declare const NamedChain: {
    inputName: () => string;
    asChain: <T>(chains: NamedChain[]) => Chain<T, any>;
    write: (name: string, chain: Chain<Record<string, any>, any>) => Chain<Record<string, any>, Record<string, any>>;
    direct: (inputName: string, chain: Chain<any, any>, outputName: string) => Chain<Record<string, any>, Record<string, any>>;
    writeValue: (name: string, value: any) => Chain<Record<string, any>, Record<string, any>>;
    overwrite: (inputName: string, chain: Chain<any, any>) => Chain<Record<string, any>, Record<string, any>>;
    read: (name: string, chain: Chain<any, any>) => Chain<Record<string, any>, Record<string, any>>;
    merge: (names: string[], combinedName: string) => Chain<Record<string, any>, Record<string, any>>;
    bundle: <T_1, E>(f: (input: Record<string, any>) => Result<T_1, E>) => Chain<Record<string, any>, Record<string, any>>;
    output: (name: string) => Chain<Record<string, any>, Record<string, any>>;
    outputInput: Chain<Record<string, any>, Record<string, any>>;
    pipeline: (namedChains: NamedChain[], onSuccess: NextFn<any>, onFailure: DieFn, initLogs: TestLogs) => void;
};
//# sourceMappingURL=NamedChain.d.ts.map