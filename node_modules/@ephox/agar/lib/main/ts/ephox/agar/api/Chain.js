import { console } from '@ephox/dom-globals';
import { Arr, Fun } from '@ephox/katamari';
import * as AsyncActions from '../pipe/AsyncActions';
import * as GeneralActions from '../pipe/GeneralActions';
import { Pipe } from '../pipe/Pipe';
import { addLogging } from './Guard';
import { Pipeline } from './Pipeline';
import { Step } from './Step';
import { addLogEntry, TestLogs } from './TestLogs';
var on = function (f) {
    var runChain = Pipe(function (input, next, die, logs) {
        f(input, function (v, newLogs) {
            next(v, newLogs);
        }, function (err, newLogs) { return die(err, newLogs); }, logs);
    });
    return {
        runChain: runChain
    };
};
var control = function (chain, guard) {
    return on(function (input, next, die, logs) {
        guard(chain.runChain, input, function (v, newLogs) {
            next(v, newLogs);
        }, die, logs);
    });
};
var mapper = function (fx) {
    return on(function (input, next, die, logs) {
        next(fx(input), logs);
    });
};
var identity = mapper(Fun.identity);
var binder = function (fx) {
    return on(function (input, next, die, logs) {
        fx(input).fold(function (err) {
            die(err, logs);
        }, function (v) {
            next(v, logs);
        });
    });
};
var op = function (fx) {
    return on(function (input, next, die, logs) {
        fx(input);
        next(input, logs);
    });
};
var async = function (fx) {
    return on(function (v, n, d, logs) { return fx(v, function (v) { return n(v, logs); }, function (err) { return d(err, logs); }); });
};
var inject = function (value) {
    return on(function (_input, next, die, logs) {
        next(value, logs);
    });
};
var injectThunked = function (f) {
    return on(function (_input, next, die, logs) {
        next(f(), logs);
    });
};
var extract = function (chain) { return ({
    runStep: chain.runChain
}); };
var fromChains = function (chains) {
    var cs = Arr.map(chains, extract);
    return on(function (value, next, die, initLogs) {
        Pipeline.async(value, cs, function (v, newLogs) { return next(v, newLogs); }, die, initLogs);
    });
};
var fromChainsWith = function (initial, chains) {
    return fromChains([inject(initial)].concat(chains));
};
var fromParent = function (parent, chains) {
    return on(function (cvalue, cnext, cdie, clogs) {
        Pipeline.async(cvalue, [extract(parent)], function (value, parentLogs) {
            var cs = Arr.map(chains, function (c) {
                return Step.raw(function (_, next, die, logs) {
                    // Replace _ with value
                    c.runChain(value, next, die, logs);
                });
            });
            Pipeline.async(cvalue, cs, function (_, finalLogs) {
                // Ignore all the values and use the original
                cnext(value, finalLogs);
            }, cdie, parentLogs);
        }, cdie, clogs);
    });
};
/**
 * @deprecated Use isolate() instead
 * TODO: remove
 */
var asStep = function (initial, chains) {
    return Step.raw(function (initValue, next, die, logs) {
        var cs = Arr.map(chains, extract);
        Pipeline.async(initial, cs, 
        // Ignore all the values and use the original
        function (_v, ls) {
            next(initValue, ls);
        }, die, logs);
    });
};
/**
 * Wrap a Chain into an "isolated" Step, with its own local state.
 * The state of the outer Step is passed-through.
 * Use the functions in ChainSequence to compose multiple Chains.
 *
 * @param initial
 * @param chain
 */
var isolate = function (initial, chain) {
    return Step.raw(function (initValue, next, die, logs) {
        Pipeline.runStep(initial, extract(chain), 
        // Ignore all the values and use the original
        function (_v, ls) {
            next(initValue, ls);
        }, die, logs);
    });
};
// Convenience functions
var debugging = op(GeneralActions.debug);
var log = function (message) {
    return on(function (input, next, die, logs) {
        // tslint:disable-next-line:no-console
        console.log(message);
        next(input, addLogEntry(logs, message));
    });
};
var label = function (label, chain) {
    return control(chain, addLogging(label));
};
var wait = function (amount) {
    return on(function (input, next, die, logs) {
        AsyncActions.delay(amount)(function () { return next(input, logs); }, die);
    });
};
var pipeline = function (chains, onSuccess, onFailure, initLogs) {
    Pipeline.async({}, Arr.map(chains, extract), function (output, logs) {
        onSuccess(output, logs);
    }, onFailure, TestLogs.getOrInit(initLogs));
};
var runStepsOnValue = function (getSteps) {
    return Chain.on(function (input, next, die, initLogs) {
        var steps = getSteps(input);
        Pipeline.async(input, steps, function (stepsOutput, newLogs) { return next(stepsOutput, newLogs); }, die, initLogs);
    });
};
var predicate = function (p) {
    return on(function (input, next, die, logs) {
        return p(input) ? next(input, logs) : die('predicate did not succeed', logs);
    });
};
export var Chain = {
    on: on,
    op: op,
    async: async,
    control: control,
    mapper: mapper,
    identity: identity,
    binder: binder,
    runStepsOnValue: runStepsOnValue,
    inject: inject,
    injectThunked: injectThunked,
    fromChains: fromChains,
    fromChainsWith: fromChainsWith,
    fromParent: fromParent,
    asStep: asStep,
    isolate: isolate,
    wait: wait,
    debugging: debugging,
    log: log,
    label: label,
    pipeline: pipeline,
    predicate: predicate
};
//# sourceMappingURL=Chain.js.map