import { Arr } from '@ephox/katamari';
export var TestLogEntryState;
(function (TestLogEntryState) {
    TestLogEntryState[TestLogEntryState["Original"] = 0] = "Original";
    TestLogEntryState[TestLogEntryState["Started"] = 1] = "Started";
    TestLogEntryState[TestLogEntryState["Finished"] = 2] = "Finished";
})(TestLogEntryState || (TestLogEntryState = {}));
var DISABLE_LOGGING = false;
// Pop level needs to change the parent. This would be so much easier with zippers.
var modifyStartedEntryTo = function (entries, f) {
    return Arr.last(entries).fold(function () { return entries; }, function (lastEntry) {
        // If the last entry has started, and has entries,
        if (lastEntry.state === TestLogEntryState.Started) {
            return Arr.last(lastEntry.entries).fold(function () {
                // We have no entries, so just modify us
                return entries.slice(0, entries.length - 1).concat([f(lastEntry)]);
            }, 
            // Great name!
            function (lastEntryLastEntry) {
                if (lastEntryLastEntry.state === TestLogEntryState.Started) {
                    // Need to keep going.
                    return entries.slice(0, entries.length - 1).concat([{
                            message: lastEntry.message,
                            state: lastEntry.state,
                            trace: lastEntry.trace,
                            entries: modifyStartedEntryTo(lastEntry.entries, f)
                        }]);
                }
                else {
                    // We have no further nesting, so just modify us
                    return entries.slice(0, entries.length - 1).concat([f(lastEntry)]);
                }
            });
        }
        else {
            return entries.slice(0, entries.length - 1).concat([f(lastEntry)]);
        }
    });
};
var modifyStartedEntry = function (logs, f) {
    return {
        history: modifyStartedEntryTo(logs.history, f)
    };
};
var modifyLastEntryTo = function (entries, f) {
    // Consider consolidating with modifyStartedEntryTo
    return Arr.last(entries).fold(function () { return [
        f({
            message: 'Unknown',
            state: TestLogEntryState.Original,
            entries: [],
            trace: null
        })
    ]; }, function (lastEntry) {
        if (lastEntry.state === TestLogEntryState.Started) {
            return entries.slice(0, entries.length - 1).concat([{
                    message: lastEntry.message,
                    state: lastEntry.state,
                    entries: modifyLastEntryTo(lastEntry.entries, f),
                    trace: lastEntry.trace
                }]);
        }
        else {
            return entries.slice(0, entries.length - 1).concat([f(lastEntry)]);
        }
    });
};
var modifyLastEntry = function (logs, f) {
    return {
        history: modifyLastEntryTo(logs.history, f)
    };
};
// Determine if we are inside a subentry
var addLogEntryTo = function (entries, newEntry) {
    if (entries.length === 0) {
        return [newEntry];
    }
    else {
        var lastEntry = entries[entries.length - 1];
        if (lastEntry.state === TestLogEntryState.Started) {
            var before = entries.slice(0, entries.length - 1);
            var newLastEntries = addLogEntryTo(lastEntry.entries, newEntry);
            return before.concat([{
                    message: lastEntry.message,
                    entries: newLastEntries,
                    state: lastEntry.state,
                    trace: lastEntry.trace
                }]);
        }
        else {
            return entries.concat([newEntry]);
        }
    }
};
// TODO: Make a Cons List for efficiency
export var addLogEntry = function (logs, message) {
    if (DISABLE_LOGGING) {
        return logs;
    }
    var newEntry = {
        message: message,
        trace: null,
        state: TestLogEntryState.Original,
        entries: []
    };
    return {
        history: addLogEntryTo(logs.history, newEntry)
    };
};
export var pushLogLevel = function (logs) {
    if (DISABLE_LOGGING) {
        return logs;
    }
    return modifyLastEntry(logs, function (entry) {
        return {
            message: entry.message,
            entries: entry.entries,
            state: TestLogEntryState.Started,
            trace: entry.trace
        };
    });
};
export var popLogLevel = function (logs) {
    if (DISABLE_LOGGING) {
        return logs;
    }
    return modifyStartedEntry(logs, function (entry) {
        return {
            message: entry.message,
            entries: entry.entries,
            state: TestLogEntryState.Finished,
            trace: entry.trace
        };
    });
};
export var addStackTrace = function (logs, err) {
    if (DISABLE_LOGGING) {
        return logs;
    }
    return modifyLastEntry(logs, function (entry) {
        return {
            message: entry.message,
            trace: err.stack,
            state: entry.state,
            entries: entry.entries
        };
    });
};
var initLogsWith = function (history) {
    return {
        history: history
    };
};
export var TestLogs = {
    getOrInit: function (logs) { return logs !== undefined ? logs : initLogsWith([]); },
    init: function () { return initLogsWith([]); }
};
//# sourceMappingURL=TestLogs.js.map