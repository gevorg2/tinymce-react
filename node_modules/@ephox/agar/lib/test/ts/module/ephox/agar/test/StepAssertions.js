import { Arr, Fun, Result } from '@ephox/katamari';
import { Chain } from 'ephox/agar/api/Chain';
import { Pipeline } from 'ephox/agar/api/Pipeline';
import { Step } from 'ephox/agar/api/Step';
import { Pprint } from '@ephox/dispute';
import { Assert } from '@ephox/bedrock-client';
var sPreserved = '..preserved..';
// We expect it to fail, and we are checking that the error is the right one
var assertError = function (label, expectedError, actualError) {
    var errMessage = actualError.message !== undefined ? actualError.message : actualError;
    try {
        Assert.eq(label + ': checking error message: ' + errMessage + '\n contains: ' + expectedError + '\nActual error: \n' + Pprint.render(actualError, Pprint.pprintAny), true, errMessage.indexOf(expectedError) > -1);
        return Result.value(actualError);
    }
    catch (err) {
        return Result.error(err);
    }
};
var assertPprintError = function (label, expectedExpectedValue, expectedActualValue, actualError) {
    try {
        Assert.eq('checking expected diff of error', actualError.diff, {
            actual: expectedActualValue,
            expected: expectedExpectedValue
        });
        return Result.value(actualError);
    }
    catch (err) {
        return Result.error(err);
    }
};
// We expect it to fail, and we somehow succeeded
var failOnSuccess = function (label, expectedError, unexpectedSuccess) {
    return label + ': Should not have passed. Expected error: ' + expectedError + '. ' +
        'Received success: ' + unexpectedSuccess;
};
// We expect it to pass, so we are checking that the passing value is the right one
var assertSuccess = function (label, expected, actual) {
    try {
        Assert.eq(label + ': checking successful value', expected, actual);
        return Result.value(actual);
    }
    catch (err) {
        return Result.error(err);
    }
};
// We expect it to pass, but we received an unexpected failure
var failOnError = function (label, expectedSuccess, unexpectedError) {
    var errMessage = unexpectedError.message !== undefined ? unexpectedError.message : unexpectedError;
    return label + '\nExpected success: ' + expectedSuccess + '.\nInstead, failed: ' + errMessage;
};
var failed = function (label, expected, step) {
    return Step.raw(function (value, next, die, initLogs) {
        step.runStep(value, function (v, newLogs) {
            var msg = failOnSuccess(label, expected, v);
            die(msg, newLogs);
        }, function (err, newLogs) {
            assertError(label, expected, err).fold(function (err) { return die(err, newLogs); }, function (_) { return next(value, newLogs); });
        }, initLogs);
    });
};
var passed = function (label, expected, step) {
    return Step.raw(function (value, next, die, initLogs) {
        step.runStep(value, function (v, newLogs) {
            var exp = expected === sPreserved ? value : expected;
            assertSuccess(label, exp, v).fold(function (err) { return die(err, newLogs); }, function (_) { return next(value, newLogs); });
        }, function (err, newLogs) {
            var msg = failOnError(label, expected, err);
            die(msg, newLogs);
        }, initLogs);
    });
};
var testStepsPass = function (expected, steps) {
    return Step.raw(function (v, next, die, initLogs) { return Pipeline.async(v, steps, function (v2, newLogs) {
        assertSuccess('Checking final step value', expected, v2).fold(function (err) { return die(err, newLogs); }, function (_) {
            next(_, newLogs);
        });
    }, function (err, newLogs) {
        var msg = failOnError('testStepsPass', expected, err);
        die(msg, newLogs);
    }, initLogs); });
};
var testStepsFail = function (expected, steps) {
    return Step.raw(function (initValue, next, die, initLogs) { return Pipeline.async(initValue, steps, function (v, newLogs) {
        var msg = failOnSuccess('testStepsFail', expected, v);
        die(msg, newLogs);
    }, function (err, newLogs) {
        assertError('testStepsFail (pipeline die)', expected, err).fold(function (err) { return die(err, newLogs); }, function () { return next(initValue, newLogs); });
    }, initLogs); });
};
var testStepFail = function (expected, step) {
    return Step.raw(function (value, next, die, initLogs) {
        step.runStep(value, function (v, newLogs) {
            var msg = failOnSuccess('testStepFail', expected, v);
            die(msg, newLogs);
        }, function (err, newLogs) {
            assertError('testStepFail', expected, err).fold(function (err) { return die(err, newLogs); }, function (_) { return next(value, newLogs); });
        }, initLogs);
    });
};
var testStepFailPprintError = function (expectedExpectedValue, expectedActualValue, step) {
    return Step.raw(function (value, next, die, initLogs) {
        step.runStep(value, function (v, newLogs) {
            var msg = failOnSuccess('testStepFail', expectedExpectedValue, v);
            die(msg, newLogs);
        }, function (err, newLogs) {
            assertPprintError('testStepFail', expectedExpectedValue, expectedActualValue, err).fold(function (err) { return die(err, newLogs); }, function (_) { return next(value, newLogs); });
        }, initLogs);
    });
};
var testChain = function (expected, chain) {
    return Step.raw(function (value, next, die, initLogs) {
        chain.runChain(value, function (actual, newLogs) {
            assertSuccess('testChain', expected, actual).fold(function (err) { return die(err, newLogs); }, function (_) { return next(value, newLogs); });
        }, function (err, newLogs) {
            var msg = failOnError('testChain', expected, err);
            die(msg, newLogs);
        }, initLogs);
    });
};
var testChainFail = function (expected, initial, chain) {
    return Step.raw(function (initValue, next, die, initLogs) {
        chain.runChain(initial, function (actual, newLogs) {
            var msg = failOnSuccess('testChainFail', expected, actual);
            die(msg, newLogs);
        }, function (err, newLogs) {
            assertError('testChainFail', expected, err).fold(function (err) { return die(err, newLogs); }, function (_) { return next(initValue, newLogs); });
        }, initLogs);
    });
};
var testChainsFail = function (expected, initial, chains) {
    return Step.raw(function (initValue, next, die, initLogs) {
        Chain.pipeline(Arr.flatten([
            [Chain.inject(initial)],
            chains
        ]), function (v, newLogs) {
            var msg = failOnSuccess('testChainsFail', expected, v);
            die(msg, newLogs);
        }, function (err, newLogs) {
            assertError('testChainsFail', expected, err).fold(function (err) { return die(err, newLogs); }, function (_) { return next(initValue, newLogs); });
        }, initLogs);
    });
};
var preserved = Fun.constant(sPreserved);
export { failed, passed, preserved, testStepFail, testStepFailPprintError, testStepsFail, testStepsPass, testChain, testChainFail, testChainsFail };
//# sourceMappingURL=StepAssertions.js.map