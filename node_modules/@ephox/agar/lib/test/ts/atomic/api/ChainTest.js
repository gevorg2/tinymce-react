import { UnitTest } from '@ephox/bedrock-client';
import { Chain } from 'ephox/agar/api/Chain';
import * as Logger from 'ephox/agar/api/Logger';
import { Pipeline } from 'ephox/agar/api/Pipeline';
import { Step } from 'ephox/agar/api/Step';
import * as StepAssertions from 'ephox/agar/test/StepAssertions';
UnitTest.asynctest('ChainTest', function (success, failure) {
    var cIsEqual = function (expected) {
        return Chain.async(function (actual, next, die) {
            if (expected === actual) {
                next(actual);
            }
            else {
                die('Cat is not a dog');
            }
        });
    };
    var cIsEqualAndChange = function (expected, newValue) {
        return Chain.async(function (actual, next, die) {
            if (expected === actual) {
                next(newValue);
            }
            else {
                die('Cat is not a dog');
            }
        });
    };
    var acc = function (ch) { return Chain.async(function (input, next, die) {
        next(input + ch);
    }); };
    var testInputValueFails = StepAssertions.testStepsFail('Output value is not a chain: dog', [
        Chain.asStep({}, [
            Chain.on(function (cInput, cNext, cDie, cLogs) {
                cNext('dog', cLogs);
            })
        ])
    ]);
    var testInputValuePasses = StepAssertions.testStepsPass({}, [
        Chain.asStep({}, [
            Chain.on(function (cInput, cNext, cDie, cLogs) {
                cNext('doge', cLogs);
            })
        ])
    ]);
    var testInputValueOfUndefinedPasses = StepAssertions.testStepsPass({}, [
        Chain.asStep({}, [
            Chain.on(function (cInput, cNext, cDie, cLogs) {
                cNext(undefined, cLogs);
            })
        ])
    ]);
    var testChainingFails = StepAssertions.testStepsFail('Cat is not a dog', [
        Chain.asStep({}, [
            Chain.inject('dog'),
            cIsEqual('cat')
        ])
    ]);
    var testChainingPasses = StepAssertions.testStepsPass({}, [
        Chain.asStep('value', [
            Chain.inject('cat'),
            cIsEqual('cat')
        ])
    ]);
    var testChainingFailsBecauseChanges = StepAssertions.testStepsFail('Cat is not a dog', [
        Chain.asStep('value', [
            Chain.inject('cat'),
            cIsEqualAndChange('cat', 'new.cat'),
            cIsEqualAndChange('cat', 'new.dog')
        ])
    ]);
    var testChainParentPasses = StepAssertions.testStepsPass({}, [
        Chain.asStep({}, [
            Chain.fromParent(Chain.inject('cat'), [
                cIsEqualAndChange('cat', 'new.cat'),
                cIsEqualAndChange('cat', 'new.dog'),
                cIsEqualAndChange('cat', 'new.elephant')
            ])
        ])
    ]);
    var testChainParentAcc = StepAssertions.testChain('Sentence: ', Chain.fromParent(Chain.inject('Sentence: '), [
        acc('T'),
        acc('h'),
        acc('i'),
        acc('s')
    ]));
    var testChainAcc = StepAssertions.testChain('Sentence: This', Chain.fromChainsWith('Sentence: ', [
        acc('T'),
        acc('h'),
        acc('i'),
        acc('s')
    ]));
    var testChainAsync = StepAssertions.testChain('async works!', Chain.async(function (_value, next) {
        next('async works!');
    }));
    var testChainAsyncFail = StepAssertions.testChainFail('async fails!', {}, Chain.async(function (_value, _next, die) {
        die('async fails!');
    }));
    var testChainAsyncChain = StepAssertions.testChain('async chains!', Chain.fromChains([
        Chain.inject('async chains!'),
        Chain.async(function (value, next, _die) {
            next(value);
        })
    ]));
    var testChainRunStepsOnValue = StepAssertions.testChain('runSteps*runStepsOnValue=succ!', Chain.fromChains([
        Chain.inject('runSteps'),
        Chain.runStepsOnValue(function (s) { return [
            Step.stateful(function (initial, next, die) {
                next(initial + '*' + s + 'OnValue');
            }),
            Step.stateful(function (v, next, die) {
                next(v + '=succ!');
            })
        ]; })
    ]));
    var testChainInjectThunked = StepAssertions.testStepsPass({}, [
        Chain.asStep({}, [
            Chain.injectThunked(function () { return 'cat'; }),
            cIsEqual('cat')
        ])
    ]);
    return Pipeline.async({}, [
        Logger.t('[When a previous link passes a failure that fails a chain, the step should fail]\n', testChainingFails),
        Logger.t('[When the last link passes a success, the step should pass]\n', testChainingPasses),
        Logger.t('[When using parent, each chain gets the first input]\n', testChainParentPasses),
        Logger.t('[When not using parent, if the chain changes the value, subsequent asserts fail]\n', testChainingFailsBecauseChanges),
        Logger.t('[When using parent, chains do not accumulate when passing]\n', testChainParentAcc),
        Logger.t('[When using fromChains, chains do accumulate when passing]\n', testChainAcc),
        Logger.t('[Chain should async]\n', testChainAsync),
        Logger.t('[Chain should async fail]\n', testChainAsyncFail),
        Logger.t('[Chain should async chain]\n', testChainAsyncChain),
        Logger.t('[Basic API: Chain.log]\n', Chain.asStep({}, [
            Chain.log('message')
        ])),
        Logger.t('[Basic API: Chain.debugging]\n', Chain.asStep({}, [
            Chain.debugging
        ])),
        Logger.t('[Basic API: Chain.wait]\n', Chain.asStep({}, [
            Chain.wait(5)
        ])),
        Logger.t('[Complex API: Chain.runStepsOnValue\n', testChainRunStepsOnValue),
        Logger.t('[Basic API: Chain.injectThunked\n', testChainInjectThunked)
    ], function () {
        success();
    }, failure);
});
UnitTest.asynctest('Chain.predicate true', function (success, failure) {
    Pipeline.async('stepstate', [
        StepAssertions.testStepsPass('stepstate', [Chain.asStep('chicken', [Chain.predicate(function (x) {
                    return x === 'chicken';
                })])])
    ], function () { return success(); }, failure);
});
UnitTest.asynctest('Chain.predicate false', function (success, failure) {
    Pipeline.async('stepstate', [
        StepAssertions.testStepsFail('predicate did not succeed', [Chain.asStep('chicken', [Chain.predicate(function (x) { return x === 'frog'; })])])
    ], function () { return success(); }, failure);
});
//# sourceMappingURL=ChainTest.js.map