import { __assign } from "tslib";
import { Blob, XMLHttpRequest, FormData, fetch } from '@ephox/dom-globals';
import { FutureResult, Result, Option, Obj, Type, Strings, Global } from '@ephox/katamari';
import * as ResponseError from './ResponseError';
import * as ResponseSuccess from './ResponseSuccess';
import { DataType } from './DataType';
import { textData } from './HttpData';
import { buildUrl } from './UrlBuilder';
var getContentType = function (requestBody) {
    return Option.from(requestBody).bind(function (b) {
        switch (b.type) {
            case DataType.JSON: return Option.some('application/json');
            case DataType.FormData: return Option.some('application/x-www-form-urlencoded; charset=UTF-8');
            case DataType.MultipartFormData: return Option.none();
            case DataType.Text: return Option.some('text/plain');
            default: return Option.some('text/plain');
        }
    });
};
var getAccept = function (responseType) {
    switch (responseType) {
        case DataType.Blob: return 'application/octet-stream';
        case DataType.JSON: return 'application/json, text/javascript';
        case DataType.Text: return 'text/plain';
        default: return '';
    }
};
var getResponseType = function (responseType) {
    switch (responseType) {
        case DataType.JSON: return Option.none();
        case DataType.Blob: return Option.some('blob');
        case DataType.Text: return Option.some('text');
        default: return Option.none();
    }
};
var createOptions = function (init) {
    var contentType = getContentType(init.body);
    var credentials = init.credentials === true ? Option.some(true) : Option.none();
    var accept = getAccept(init.responseType) + ', */*; q=0.01';
    var headers = init.headers !== undefined ? init.headers : {};
    var responseType = getResponseType(init.responseType);
    var progress = Type.isFunction(init.progress) ? Option.some(init.progress) : Option.none();
    return {
        contentType: contentType,
        responseType: responseType,
        credentials: credentials,
        accept: accept,
        headers: headers,
        progress: progress
    };
};
var applyOptions = function (request, options) {
    options.contentType.each(function (contentType) { return request.setRequestHeader('Content-Type', contentType); });
    request.setRequestHeader('Accept', options.accept);
    options.credentials.each(function (creds) { return request.withCredentials = creds; });
    options.responseType.each(function (responseType) { return request.responseType = responseType; });
    options.progress.each(function (progressFunction) { return request.upload.addEventListener('progress', function (event) { return progressFunction(event.loaded, event.total); }); });
    Obj.each(options.headers, function (v, k) { return request.setRequestHeader(k, v); });
};
var toNativeFormData = function (formDataInput) {
    var nativeFormData = new FormData();
    Obj.each(formDataInput, function (value, key) {
        nativeFormData.append(key, value);
    });
    return nativeFormData;
};
var getData = function (body) { return Option.from(body).map(function (b) {
    if (b.type === DataType.JSON) {
        return JSON.stringify(b.data);
    }
    else if (b.type === DataType.FormData) {
        return toNativeFormData(b.data);
    }
    else if (b.type === DataType.MultipartFormData) {
        return toNativeFormData(b.data);
    }
    else {
        return b;
    }
}); };
var send = function (init) {
    return FutureResult.nu(function (callback) {
        var request = new XMLHttpRequest();
        request.open(init.method, buildUrl(init.url, Option.from(init.query)), true); // enforced async! enforced type as String!
        var options = createOptions(init);
        applyOptions(request, options);
        var onError = function () {
            ResponseError.handle(init.url, init.responseType, request).get(function (err) { return callback(Result.error(err)); });
        };
        var onLoad = function () {
            // Local files and Cors errors return status 0.
            // The only way we can decifer a local request is request url starts with 'file:' and allow local files to succeed.
            if (request.status === 0 && !Strings.startsWith(init.url, 'file:')) {
                onError();
            }
            else if (request.status < 100 || request.status >= 400) {
                onError();
            }
            else {
                ResponseSuccess.validate(init.responseType, request).get(callback);
            }
        };
        request.onerror = onError;
        request.onload = onLoad;
        getData(init.body).fold(function () { return request.send(); }, function (data) {
            request.send(data);
        });
    });
};
var empty = function () { return textData(''); };
var post = function (init) {
    return send(__assign(__assign({}, init), { method: "post" /* Post */ }));
};
var put = function (init) {
    return send(__assign(__assign({}, init), { method: "put" /* Put */ }));
};
var get = function (init) {
    return send(__assign(__assign({}, init), { method: "get" /* Get */, body: empty() }));
};
var del = function (init) {
    return send(__assign(__assign({}, init), { method: "delete" /* Delete */, body: empty() }));
};
var sendProgress = function (init, loaded) {
    if (Type.isFunction(init.progress)) {
        init.progress(loaded);
    }
};
var getMimeType = function (headers) {
    return Option.from(headers.get('content-type')).map(function (value) {
        return value.split(';')[0];
    });
};
var fetchDownload = function (init) {
    return FutureResult.nu(function (resolve) {
        var fail = function (message, status) {
            resolve(Result.error({
                message: message,
                status: status,
                responseText: ''
            }));
        };
        var failOnError = function (e) {
            fail("Could not load url " + init.url, 500 /* InternalServerError */);
        };
        var downloadStream = function (response) {
            var body = response.body;
            var chunks = [];
            var loaded = 0;
            var mime = getMimeType(response.headers);
            sendProgress(init, 0);
            if (body) {
                var reader_1 = body.getReader();
                var process_1 = function (result) {
                    if (result.done) {
                        resolve(Result.value(new Blob(chunks, { type: mime.getOr('') })));
                    }
                    else {
                        chunks.push(result.value);
                        loaded += result.value.length;
                        sendProgress(init, loaded);
                        reader_1.read().then(process_1).catch(failOnError);
                    }
                };
                reader_1.read().then(process_1).catch(failOnError);
            }
            else {
                fail('Failed to get response body', 500 /* InternalServerError */);
            }
        };
        fetch(init.url, {
            method: 'get',
            headers: init.headers,
            credentials: init.credentials ? 'include' : 'omit'
        }).then(function (response) {
            if (response.status < 100 || response.status >= 400) {
                fail("Could not load url " + init.url, response.status);
            }
            else {
                downloadStream(response);
            }
        }).catch(failOnError);
    });
};
var fallbackDownload = function (init) {
    sendProgress(init, 0);
    return get({
        url: init.url,
        responseType: DataType.Blob,
        headers: init.headers
    }).mapResult(function (blob) {
        sendProgress(init, blob.size);
        return blob;
    });
};
var download = function (init) {
    return Obj.get(Global, 'fetch').exists(Type.isFunction) ? fetchDownload(init) : fallbackDownload(init);
};
export { send, post, put, get, del, download };
//# sourceMappingURL=Http.js.map